<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>欢迎投稿</title>
      <link href="/undefined/fcdefbb0.html"/>
      <url>/undefined/fcdefbb0.html</url>
      
        <content type="html"><![CDATA[<h1 id="投稿告示"><a href="#投稿告示" class="headerlink" title=" 投稿告示 "></a><center> 投稿告示 </center></h1><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/medias/articles/%E6%AC%A2%E8%BF%8E%E6%8A%95%E7%A8%BF.jpg" alt="欢迎投稿"></p><h2 id="分享目的"><a href="#分享目的" class="headerlink" title="分享目的"></a>分享目的</h2><hr><h4 id="1、共建分享环境；"><a href="#1、共建分享环境；" class="headerlink" title="1、共建分享环境；"></a>1、共建分享环境；</h4><h4 id="2、为广大的网友提供一个分享平台；"><a href="#2、为广大的网友提供一个分享平台；" class="headerlink" title="2、为广大的网友提供一个分享平台；"></a>2、为广大的网友提供一个分享平台；</h4><h4 id="3、实现自己写的东西有人看，因而促进自己更努力去学习，越分享越快乐！"><a href="#3、实现自己写的东西有人看，因而促进自己更努力去学习，越分享越快乐！" class="headerlink" title="3、实现自己写的东西有人看，因而促进自己更努力去学习，越分享越快乐！"></a>3、实现自己写的东西有人看，因而促进自己更努力去学习，越分享越快乐！</h4><h4 id="4、在分享过程中获得了沉淀、学习、与成长。"><a href="#4、在分享过程中获得了沉淀、学习、与成长。" class="headerlink" title="4、在分享过程中获得了沉淀、学习、与成长。"></a>4、在分享过程中获得了沉淀、学习、与成长。</h4><h2 id="来搞要求"><a href="#来搞要求" class="headerlink" title="来搞要求"></a>来搞要求</h2><hr><h4 id="1、不能违反国家法律法规；"><a href="#1、不能违反国家法律法规；" class="headerlink" title="1、不能违反国家法律法规；"></a>1、不能违反国家法律法规；</h4><h4 id="2、不能违反道德规范；"><a href="#2、不能违反道德规范；" class="headerlink" title="2、不能违反道德规范；"></a>2、不能违反道德规范；</h4><h4 id="3、······（没有了，就这点要求）······"><a href="#3、······（没有了，就这点要求）······" class="headerlink" title="3、······（没有了，就这点要求）······"></a>3、······（没有了，就这点要求）······</h4><h2 id="来搞方式"><a href="#来搞方式" class="headerlink" title="来搞方式"></a>来搞方式</h2><hr><p>首先编辑好的markdown文件，然后</p><p>发送到：<a href="mailto:2297541744@qq.com" target="_blank" rel="noopener">2297541744@qq.com</a></p><p>或者发送到 ：<a href="mailto:mryzj0716@gmail.com" target="_blank" rel="noopener">mryzj0716@gmail.com</a> </p><p>站长审核通过后就会发布！感谢大家的来稿！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 告示 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 告示 </tag>
            
            <tag> 投稿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ExoPlayer详解——高级主题（官方文档）</title>
      <link href="/undefined/23d9b12d.html"/>
      <url>/undefined/23d9b12d.html</url>
      
        <content type="html"><![CDATA[<p>﻿&gt;  #####  ExoPlayer详解系列文章</p><blockquote><ul><li><a href="https://blog.csdn.net/MRYZJ/article/details/98657228" target="_blank" rel="noopener">ExoPlayer详解——入门（官方文档）</a></li><li><a href="https://blog.csdn.net/MRYZJ/article/details/98759532" target="_blank" rel="noopener">ExoPlayer详解——媒体类型（官方文档）</a></li><li><a href="https://blog.csdn.net/MRYZJ/article/details/98853258" target="_blank" rel="noopener">ExoPlayer详解——高级主题（官方文档）</a></li></ul></blockquote><h1 id="一、数字版权管理"><a href="#一、数字版权管理" class="headerlink" title="一、数字版权管理"></a>一、数字版权管理</h1><p>ExoPlayer使用Android的MediaDrmAPI来支持受DRM保护的播放。不同支持的DRM方案所需的最低Android版本以及支持它们的流式格式为：</p><table><thead><tr><th align="left"><strong>DRM格式</strong></th><th><strong>Android<br>版本号</strong></th><th><strong>Android <br>API级别</strong></th><th align="left"><strong>支持的格式</strong></th></tr></thead><tbody><tr><td align="left">Widevine“cenc”</td><td>4.4</td><td>19</td><td align="left">DASH，HLS（仅限FMP4）</td></tr><tr><td align="left">Widevine“cbcs”，“cbc1”和“cens”</td><td>7.1</td><td>25</td><td align="left">DASH，HLS（仅限FMP4）</td></tr><tr><td align="left">ClearKey</td><td>5</td><td>21</td><td align="left">DASH</td></tr><tr><td align="left">PlayReady SL2000</td><td>AndroidTV</td><td>AndroidTV</td><td align="left">DASH，SmoothStreaming，HLS（仅限FMP4）</td></tr></tbody></table><p>为了使用ExoPlayer播放受DRM保护的内容，您的应用必须在实例化播放器时注入<code>DrmSessionManager</code> 。<code>ExoPlayerFactory</code>提供允许这样做的方法。</p><p>该库提供了一个名为<code>DrmSessionManager</code>的默认实现， <code>DefaultDrmSessionManager</code>适用于大多数用例。在<a href="https://github.com/google/ExoPlayer/tree/release-v2/demos/main" target="_blank" rel="noopener">主应用程序</a><code>PlayerActivity</code>中演示如何``在实例化播放器时创建和注入DefaultDrmSessionManager。</p><p>对于某些用例，可能需要进行其他配置，如以下部分所述。</p><h2 id="1、Key-rotation"><a href="#1、Key-rotation" class="headerlink" title="1、Key rotation"></a>1、Key rotation</h2><p>要使用Key rotation（个人觉得是“转换密钥”的意思）播放流，必须在实例化<code>DefaultDrmSessionManager</code>时将<code>multiSession</code>构造函数参数设置为<code>true</code>。</p><blockquote><p><a href="https://github.com/google/ExoPlayer/issues/4133" target="_blank" rel="noopener">已知问题＃4133</a> - 当key rotation发生时，播放可能会有轻微的暂停。</p></blockquote><blockquote><p><a href="https://github.com/google/ExoPlayer/issues/3561" target="_blank" rel="noopener">已知问题＃3561</a> - 在API级别22及以下，当Key rotation发生时，输出表面可能会闪烁。</p></blockquote><h2 id="2、Multi-key-content"><a href="#2、Multi-key-content" class="headerlink" title="2、Multi-key content"></a>2、Multi-key content</h2><p>多密钥内容由多个流组成，其中一些流使用与其他流不同的密钥。可以通过两种方式之一播放多密钥内容，具体取决于许可证服务器的配置方式。</p><ul><li><strong>案例1：许可证服务器响应内容的所有密钥</strong></li></ul><p>在这种情况下，许可证服务器配置为当它收到对一个密钥的请求时，它会响应内容的所有密钥。这种情况由ExoPlayer处理，无需任何特殊配置。流之间的适应（例如SD和HD视频）即使使用不同的密钥也是无缝的。</p><p>在可能的情况下，我们建议您将许可证服务器配置为以这种方式运行。它是支持多密钥内容回放的最有效和最强大的方式，因为它不需要客户端发出多个许可证请求来访问不同的流。</p><ul><li><strong>案例2：许可证服务器仅响应请求的密钥</strong></li></ul><p>在这种情况下，许可证服务器配置为仅响应请求中指定的密钥。通过在实例化<code>DefaultDrmSessionManager</code>时将<code>multiSession</code>构造函数参数设置为<code>true</code>可以使用此许可证服务器配置来播放多密钥内容。</p><p>我们不建议您将许可证服务器配置为以这种方式运行。它需要额外的许可证请求来播放多密钥内容，这比上述替代方案效率低且稳健。</p><blockquote><p><a href="https://github.com/google/ExoPlayer/issues/4133" target="_blank" rel="noopener">已知问题＃4133</a> - 使用此许可证服务器配置时，在使用不同密钥的流之间进行调整时，播放可能会略有暂停。</p></blockquote><h2 id="3、Offline-keys"><a href="#3、Offline-keys" class="headerlink" title="3、Offline keys"></a>3、Offline keys</h2><p><code>DefaultDrmSessionManager</code>可以通过设置<code>offlineLicenseKeySetId</code>构造函数参数来加载脱机密钥集合。这允许使用存储在具有指定id的离线密钥集合中的密钥进行回放。</p><blockquote><p><a href="https://github.com/google/ExoPlayer/issues/3872" target="_blank" rel="noopener">已知问题＃3872</a> - 每次播放只能指定一个离线密钥集合。因此，仅当如上面的情况1中所述配置许可证服务器时，才支持多密钥内容的离线回放。</p></blockquote><hr><hr><h1 id="二、故障排除"><a href="#二、故障排除" class="headerlink" title="二、故障排除"></a>二、故障排除</h1><ul><li><strong>为什么某些媒体文件不可搜索？</strong></li></ul><p>默认情况下，ExoPlayer不支持在媒体中搜索，其中执行准确搜索操作的唯一方法是播放器扫描并索引整个文件。ExoPlayer认为此类文件不可见。大多数现代媒体容器格式包括用于搜索的元数据（例如，样本索引），具有良好定义的搜索算法（例如，针对Ogg的内插二分搜索），或指示其内容是恒定比特率。在这些情况下，ExoPlayer可以实现高效的搜索操作并提供支持。</p><p>如果您需要搜索但有不可搜索的媒体，我们建议您将内容转换为使用更合适的容器格式。对于MP3，ADTS和AMR文件，还可以使假设文件具有恒定比特率下求，如所描述 <a href="https://exoplayer.dev/progressive.html#enabling-constant-bitrate-seeking" target="_blank" rel="noopener">这里</a>。</p><ul><li><strong>为什么有些MPEG-TS文件无法播放？</strong></li></ul><p>某些MPEG-TS文件不包含访问单元分隔符（AUD）。默认情况下，ExoPlayer依靠AUD来便宜地检测帧边界。同样，某些MPEG-TS文件不包含IDR关键帧。默认情况下，这些是ExoPlayer考虑的唯一关键帧类型。</p><p>当被要求播放缺少AUD或IDR关键帧的MPEG-TS文件时，ExoPlayer似乎会陷入缓冲状态。如果需要播放此类文件，可以分别使用<a href="https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.html#FLAG_DETECT_ACCESS_UNITS" target="_blank" rel="noopener">FLAG_DETECT_ACCESS_UNITS</a>和 <a href="https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/extractor/ts/DefaultTsPayloadReaderFactory.html#FLAG_ALLOW_NON_IDR_KEYFRAMES" target="_blank" rel="noopener">FLAG_ALLOW_NON_IDR_KEYFRAMES</a>。这些标志可以使用<code>setTsExtractorFlags</code>设置<code>DefaultExtractorsFactory</code> 。除了相对于基于AUD的帧边界检测而言计算上昂贵之外，使用 <code>FLAG_DETECT_ACCESS_UNITS</code>没有副作用。使用<code>FLAG_ALLOW_NON_IDR_KEYFRAMES</code>可能会在播放开始时以及在播放某些MPEG-TS文件时的搜索后立即导致暂时的视觉损坏。</p><ul><li><strong>为什么有些MP4 / FMP4文件播放不正确？</strong></li></ul><p>某些MP4 / FMP4文件包含编辑列表，可通过跳过，移动或重复样本列表来重写媒体时间轴。ExoPlayer部分支持应用编辑列表。例如，它可以从同步样本开始延迟或重复样本组，但它不会截断音频样本或预卷媒体以进行不在同步样本上启动的编辑。</p><p>如果您看到部分媒体意外丢失或重复，请尝试设置<a href="https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/extractor/mp4/Mp4Extractor.html#FLAG_WORKAROUND_IGNORE_EDIT_LISTS" target="_blank" rel="noopener">Mp4Extractor.FLAG_WORKAROUND_IGNORE_EDIT_LISTS</a>或 <a href="https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/extractor/mp4/FragmentedMp4Extractor.html#FLAG_WORKAROUND_IGNORE_EDIT_LISTS" target="_blank" rel="noopener">FragmentedMp4Extractor.FLAG_WORKAROUND_IGNORE_EDIT_LISTS</a>，这将使提取器完全忽略编辑列表。这些文件可以使用<code>setMp4ExtractorFlags</code>或 <code>setFragmentedMp4ExtractorFlags</code>设置<code>DefaultExtractorsFactory</code>。</p><ul><li><strong>为什么有些流会因HTTP响应代码301或302而失败？</strong></li></ul><p>HTTP响应代码301和302都指示重定向。可以在<a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes" target="_blank" rel="noopener">维基百科</a>上找到简要描述。当ExoPlayer发出请求并收到状态码为301或302的响应时，它通常会遵循重定向并正常开始播放。默认情况下不会发生这种情况的一种情况是跨协议重定向。跨协议重定向是从HTTPS重定向到HTTP或反之亦然（或者不太常见，在另一对协议之间）。您可以使用<a href="https://www.gnu.org/software/wget/manual/wget.html" target="_blank" rel="noopener">wget</a>命令行工具测试URL是否导致跨协议重定向，如下所示：</p><figure class="highlight lsl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget <span class="string">"https://yourserver.com/test.mp3"</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span>  | grep Location</span><br></pre></td></tr></tbody></table></figure><p>输出应该如下所示：</p><figure class="highlight groovy"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ wget <span class="string">"https://yourserver.com/test.mp3"</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span>  | grep Location</span><br><span class="line"><span class="string">Location:</span> <span class="string">https:</span><span class="comment">//second.com/test.mp3 [following]</span></span><br><span class="line"><span class="string">Location:</span> <span class="string">http:</span><span class="comment">//third.com/test.mp3 [following]</span></span><br></pre></td></tr></tbody></table></figure><p>在此示例中，有两个重定向。第一个重定向是从 <code>https://yourserver.com/test.mp3到https://second.com/test.mp3</code>。两者都是HTTPS，因此这不是跨协议重定向。第二重定向是从 <code>https://second.com/test.mp3</code>到<code>http://third.com/test.mp3</code>。这会从HTTPS重定向到HTTP，因此是跨协议重定向。ExoPlayer在默认配置中不会遵循此重定向，这意味着播放将失败。</p><p>如果需要，可以在实例化<code>ExoPlayer</code>应用程序中<code>HttpDataSource.Factory</code>使用的实例时，将ExoPlayer配置为遵循跨协议重定向。<code>[DefaultHttpDataSourceFactory](https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/upstream/DefaultHttpDataSourceFactory.html)</code>具有为此目的接受参数的构造函数<code>allowCrossProtocolRedirects</code>，其他 <code>HttpDataSource.Factory</code>实现也是如此。将这些参数设置为<code>true</code>以启用跨协议重定向。</p><ul><li><strong>为什么有些流因UnrecognizedInputFormatException而失败？</strong></li></ul><p>此问题与表单的播放失败有关：</p><figure class="highlight livecodeserver"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UnrecognizedInputFormatException: None <span class="keyword">of</span> <span class="keyword">the</span> available extractors</span><br><span class="line">(MatroskaExtractor, FragmentedMp4Extractor, ...) could <span class="built_in">read</span> <span class="keyword">the</span> stream.</span><br></pre></td></tr></tbody></table></figure><p>这种失败有两种可能的原因。最常见的原因是您尝试使用<code>ProgressiveMediaSource</code>播放DASH（mpd），HLS（m3u8）或SmoothStreaming（ism，isml）内容。要播放这些流，你必须使用正确<code>MediaSource</code>的实现，这分别是<code>DashMediaSource</code>， <code>HlsMediaSource</code>和<code>SsMediaSource</code>。如果您不知道媒体的类型，那么经常可以使用<a href="https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/util/Util.html#inferContentType-android.net.Uri-" target="_blank" rel="noopener">Util.inferContentType</a>，如 演示应用程序ExoPlayer中<code>PlayerActivity</code>所示。</p><p>第二个不常见的原因是，ExoPlayer不支持您尝试播放的媒体的容器格式。在这种情况下，故障按预期工作，但随意向我们的问题跟踪器提交功能请求 ，包括容器格式和测试流的详细信息。请在提交新功能之前搜索现有功能请求。</p><ul><li><strong>为什么setPlaybackParameters在某些设备上无法正常工作？</strong></li></ul><p>在Android M及更早版本上运行应用程序的调试版本时，使用<a href="https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/Player.html#setPlaybackParameters-com.google.android.exoplayer2.PlaybackParameters-" target="_blank" rel="noopener">setPlaybackParameters</a> API 时可能会遇到性能不稳定，可听见的工件和高CPU利用率。这是因为对于在这些Android版本上运行的调试版本，禁用了对此API很重要的优化。</p><p>请务必注意，此问题仅影响调试版本。它并不会影响发布版本，使这种优化始终启用。因此，您向最终用户提供的版本不应受此问题的影响。</p><ul><li><strong>“在错误的线程上访问播放器”警告意味着什么？</strong></li></ul><p>如果您看到此警告，则应用程序中的某些代码正在错误的线程上访问 <code>SimpleExoPlayer</code>（请检查报告的堆栈跟踪！）。只需从单个线程访问ExoPlayer实例。在大多数情况下，这应该是应用程序的主线程。有关详细信息，请阅读<a href="https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/ExoPlayer.html" target="_blank" rel="noopener">ExoPlayer Javadoc的“线程模型”部分</a>。</p><ul><li><strong>如何修复“意外状态行：ICY 200 OK”？</strong></li></ul><p>如果服务器响应包含ICY状态行，而不是符合HTTP的状态行，则可能会出现此问题。不推荐使用ICY状态行，因此如果您控制服务器，则应更新它以提供符合HTTP的响应。如果你不能这样做，那么使用 <a href="https://github.com/google/ExoPlayer/tree/release-v2/extensions/okhttp" target="_blank" rel="noopener">OkHttp扩展</a>将解决问题，因为它能够正确处理ICY状态行。</p><ul><li><strong>如何查询正在播放的流是否为直播流？</strong></li></ul><p>您可以查询ExoPlayer的<a href="https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/ExoPlayer.html#isCurrentWindowDynamic--" target="_blank" rel="noopener">isCurrentWindowDynamic</a>方法。动态窗口意味着正在播放的流是直播流。</p><ul><li><strong>当我的应用程序背景化时，如何保持音频播放？</strong></li></ul><p>当您的应用在后台时，您需要采取一些步骤来确保继续播放音频：</p><p>您需要有一个正在运行的<a href="https://developer.android.com/guide/components/services.html#Foreground" target="_blank" rel="noopener">前台服务</a>。这可以防止系统终止您的进程以释放资源。<br>您需要持有<a href="https://developer.android.com/reference/android/net/wifi/WifiManager.WifiLock.html" target="_blank" rel="noopener">WifiLock</a>和<a href="https://developer.android.com/reference/android/os/PowerManager.WakeLock.html" target="_blank" rel="noopener">WakeLock</a>。这些确保系统保持WiFi无线电和CPU唤醒。<br>一旦音频不再播放，停止服务并释放锁定非常重要。</p><hr><hr><h1 id="三、定制"><a href="#三、定制" class="headerlink" title="三、定制"></a>三、定制</h1><p>ExoPlayer库的核心是<strong>ExoPlayer界面</strong>。一个<code>ExoPlayer</code>公开的传统高层次的媒体播放器功能，比如缓冲介质，播放，暂停和寻求的能力。实现的目的是对正在播放的媒体类型，存储方式和位置以及如何呈现媒体类型做出一些假设（并因此施加很少的限制）。实现不是直接<code>ExoPlayer</code>实现媒体的加载和呈现，而是将此工作委托给创建播放器或准备播放时注入的组件。所有ExoPlayer实现共有的组件是：</p><ul><li><code>MediaSource</code>定义要播放的媒体，加载媒体，并从中读取加载的媒体。 <code>MediaSource</code>在播放开始时被<code>ExoPlayer.prepare</code>注入。</li><li><code>Renderers</code>渲染媒体的各个组成部分。在创建播放器时注入<code>Renderer</code>。</li><li><code>TrackSelector</code>选择由每个<code>MediaSource</code>可用<code>Renderer</code>提供的轨道。创建播放器时注入<code>TrackSelector</code>.</li><li><code>LoadControl</code>控制<code>MediaSource</code>何时缓冲更多媒体，以及缓冲多少媒体。创建播放器时注入<code>LoadControl</code>.</li></ul><p>该库为常见用例提供了这些组件的默认实现。一个ExoPlayer可以使用这些组件，但也可以使用自定义的实现是否需要非标准行为建造。自定义实现的一些用例是：</p><ul><li><code>Renderer</code>——您可能希望实现自定义<code>Renderer</code>来处理库提供的默认实现不支持的媒体类型。</li><li><code>TrackSelector</code>——实现自定义<code>TrackSelector</code>允许应用程序开发人员更改选择由每个<code>MediaSource</code>可用<code>Renderer</code>消耗的轨道的方式。</li><li><code>LoadControl</code>——实施自定义<code>LoadControl</code>允许应用开发者更改播放器的缓冲策略。</li><li><code>Extractor</code>——如果您需要实现支持库当前不支持的容器格式，请考虑实现一个自定义<code>Extractor</code>类，然后可以将该类用于<code>ProgressiveMediaSource</code>播放该类型的媒体。</li><li><code>MediaSource</code>——如果您希望获得以自定义<code>MediaSource</code>方式提供给渲染器的媒体示例，或者您希望实现自定义<code>MediaSource</code>合成行为，则实现自定义类可能是合适的。</li><li><code>DataSource</code>——ExoPlayer的上游包已经包含了许多<code>DataSource</code>针对不同用例的 实现。您可能希望实现自己的<code>DataSource</code>类以另一种方式加载数据，例如通过自定义协议，使用自定义HTTP堆栈或自定义持久缓存。</li></ul><p>整个库中都存在注入实现播放器功能的组件的概念。组件的默认实现委托工作以进一步注入组件。这允许使用自定义实现单独替换许多子组件。例如，默认<code>MediaSource</code>实现需要通过自己的工厂注入一个或多个<code>DataSource</code>工厂。通过提供自定义<code>DataSource</code>工厂，可以从非标准源或通过不同的网络堆栈加载数据。</p><p>构建自定义组件时，建议执行以下操作：</p><ul><li>如果自定义组件需要将事件报告回应用程序，我们建议您使用与现有ExoPlayer组件相同的模型执行此操作，其中事件侦听器与<code>Handler</code>一起传递给组件的构造函数。</li><li>我们建议自定义组件使用与现有ExoPlayer组件相同的模型，以允许应用程序在播放期间重新配置，如下面的部分所述。为此，自定义组件应在<code>handleMessage</code>方法中实现 <code>PlayerMessage.Target</code>和接收配置更改。应用程序代码应通过调用ExoPlayer的<code>createMessage</code>方法，配置消息并使用<code>PlayerMessage.send</code>发送到组件来传递配置更改。</li></ul><h2 id="1、将消息发送到组件"><a href="#1、将消息发送到组件" class="headerlink" title="1、将消息发送到组件"></a>1、将消息发送到组件</h2><p>可以向ExoPlayer组件发送消息。这些可以使用<code>ExoPlayer.createMessage</code>创建，然后使用<code>PlayerMessage.send</code>发送。默认情况下，消息尽快在回放线程上传递，但可以通过设置另一个回调线程（使用 <code>PlayerMessage.setHandler</code>）或指定传送回放位置（使用<code>PlayerMessage.setPosition</code>）来自定义。发送要在回放线程上传递的消息确保它们按照在播放器上执行的任何其他操作的顺序执行。</p><p>大多数ExoPlayer的开箱即用渲染器都支持允许在播放期间更改其配置的消息。例如，音频渲染器接受消息来设置音量，视频渲染器接受消息来设置曲面。这些消息应在回放线程上传递，以确保线程安全。</p><hr><hr><h1 id="四、电池消耗"><a href="#四、电池消耗" class="headerlink" title="四、电池消耗"></a>四、电池消耗</h1><h2 id="1、媒体播放导致电池消耗有多重要？"><a href="#1、媒体播放导致电池消耗有多重要？" class="headerlink" title="1、媒体播放导致电池消耗有多重要？"></a>1、媒体播放导致电池消耗有多重要？</h2><p>避免不必要的电池消耗是开发优秀Android应用程序的一个重要方面。媒体播放可能是电池耗尽的主要原因，但其对特定应用的重要性在很大程度上取决于其使用模式。如果应用程序每天仅用于播放少量媒体，则相应的电池消耗将仅占设备总消耗的一小部分。在这种情况下，在选择使用哪个播放器时，优先考虑功能集和可靠性优于电池是有意义的。另一方面，如果应用程序通常每天用于播放大量媒体，那么在选择多种可行选项时，应优先考虑优化电池消耗。</p><h2 id="2、ExoPlayer的功效如何？"><a href="#2、ExoPlayer的功效如何？" class="headerlink" title="2、ExoPlayer的功效如何？"></a>2、ExoPlayer的功效如何？</h2><p>Android设备和媒体内容生态系统的多样性意味着很难对ExoPlayer的电池消耗做出广泛适用的陈述，特别是它与Android的 MediaPlayer API的比较。绝对和相对性能都因硬件，Android版本和正在播放的媒体而异。因此，下面提供的信息应仅作为指导。</p><h3 id="（1）、视频回放"><a href="#（1）、视频回放" class="headerlink" title="（1）、视频回放"></a>（1）、视频回放</h3><p>对于视频播放，我们的测量显示ExoPlayer和MediaPlayer消耗的功率相近。在两种情况下，显示和解码视频流所需的功率是相同的，并且这些功能占回放期间消耗的大部分功率。</p><p>无论使用哪种媒体播放器，在<code>SurfaceView</code>输出和<code>TextureView</code>输出之间进行选择都会对功耗产生重大影响。 <code>SurfaceView</code>更高效，<code>TextureView</code>在视频播放过程中总功耗增加了30％。因此，应尽可能优先考虑<code>SurfaceView</code>。了解更多关于<code>SurfaceView</code>和<code>TextureView</code>之间进行选择 ，并在<a href="https://exoplayer.dev/ui-components.html#choosing-a-surface-type" target="_blank" rel="noopener">这里</a>。</p><p>以下是在Pixel 2上播放1080p和480p视频时的一些功耗测量，使用<a href="https://www.msoon.com/battery-configuration" target="_blank" rel="noopener">Monsoon功率监视器</a>测量。如上所述，这些数字不应用于得出有关Android设备和媒体内容生态系统功耗的一般结论。</p><table><thead><tr><th></th><th>媒体播放器</th><th>ExoPlayer</th></tr></thead><tbody><tr><td>SurfaceView</td><td>1080p</td><td>202毫安</td></tr><tr><td>TextureView</td><td>1080p</td><td>219毫安</td></tr><tr><td>SurfaceView</td><td>480p</td><td>194毫安</td></tr><tr><td>TextureView</td><td>480p</td><td>212毫安</td></tr></tbody></table><h3 id="（2）、音频播放"><a href="#（2）、音频播放" class="headerlink" title="（2）、音频播放"></a>（2）、音频播放</h3><p>对于音频播放，我们的测量表明 ExoPlayer 可以比 MediaPlayer 消耗更多的功率。对于支持音频转移的设备尤其如此，它允许将音频处理从CPU转移到专用信号处理器。MediaPlayer能够利用音频转移来降低功耗，而ExoPlayer则不能，因为Android框架中没有用于启用它的公共API。请注意，这也意味着任何其他应用程序级别的媒体播放器或<code>AudioTrack</code>直接使用的应用程序都无法使用音频转移。</p><p>是否值得增加ExoPlayer的稳健性，灵活性和功能集超过MediaPlayer仅用于音频的用例的功耗是应用程序开发人员必须决定的，同时考虑他们的要求和应用程序使用模式。</p><p>Android Q中的新公共API将使ExoPlayer以及其他应用程序级媒体播放器能够利用音频转移功能。我们计划在未来的ExoPlayer版本中使用这些API。</p><hr><hr><h1 id="五、APK收缩"><a href="#五、APK收缩" class="headerlink" title="五、APK收缩"></a>五、APK收缩</h1><p>最小化APK大小是开发优秀Android应用程序的一个重要方面。在针对发展中市场以及开发Android Instant App时尤其如此。对于这种情况，可能需要最小化APK中包含的ExoPlayer库的大小。本页概述了一些有助于实现此目的的简单步骤。</p><h2 id="1、使用模块化依赖项"><a href="#1、使用模块化依赖项" class="headerlink" title="1、使用模块化依赖项"></a>1、使用模块化依赖项</h2><p>使用ExoPlayer最方便的方法是向完整库添加依赖项：</p><figure class="highlight clean"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implementation</span> <span class="string">'com.google.android.exoplayer:exoplayer:2.X.X'</span></span><br></pre></td></tr></tbody></table></figure><p>但是，这可能会提供比您的应用需求更多的功能。相反，只依赖于您实际需要的库模块。例如，以下内容将添加对Core，DASH和UI库模块的依赖关系，这对于播放DASH内容的应用程序可能是必需的：</p><figure class="highlight clean"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implementation</span> <span class="string">'com.google.android.exoplayer:exoplayer-core:2.X.X'</span></span><br><span class="line"><span class="keyword">implementation</span> <span class="string">'com.google.android.exoplayer:exoplayer-dash:2.X.X'</span></span><br><span class="line"><span class="keyword">implementation</span> <span class="string">'com.google.android.exoplayer:exoplayer-ui:2.X.X'</span></span><br></pre></td></tr></tbody></table></figure><h2 id="1、使用ProGuard并缩小资源"><a href="#1、使用ProGuard并缩小资源" class="headerlink" title="1、使用ProGuard并缩小资源"></a>1、使用ProGuard并缩小资源</h2><p>通过在应用模块的<code>build.gradle</code>文件中启用<code>ProGuard</code>，可以删除应用未使用的类：</p><figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">buildTypes</span> {</span><br><span class="line">   <span class="section">release</span> {</span><br><span class="line">       <span class="attribute">minifyEnabled</span> <span class="literal">true</span></span><br><span class="line">       shrinkResources <span class="literal">true</span></span><br><span class="line">       useProguard <span class="literal">true</span></span><br><span class="line">       proguardFiles = [</span><br><span class="line">           getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>),</span><br><span class="line">           <span class="string">'proguard-rules.pro'</span></span><br><span class="line">       ]</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>ExoPlayer的结构允许<code>ProGuard</code>删除未使用的功能。例如，对于播放DASH内容的应用，ExoPlayer对APK大小的贡献可以减少大约40％。</p><p><code>shrinkResources</code>在app模块的<code>build.gradle</code>文件中启用可以进一步减小尺寸。</p><h2 id="2、指定您的应用需要哪些提取器"><a href="#2、指定您的应用需要哪些提取器" class="headerlink" title="2、指定您的应用需要哪些提取器"></a>2、指定您的应用需要哪些提取器</h2><p>如果您的应用使用<code>ProgressiveMediaSource</code>，请注意默认情况下会使用 <code>DefaultExtractorsFactory</code>。DefaultExtractorsFactory取决于ExoPlayer库中提供的所有<code>Extractor</code>\实现，因此<code>ProGuard</code>不会删除它们。如果您知道您的应用只需要播放少量容器格式，则可以指定自己的容器格式<code>ExtractorsFactory</code>。例如，只需要播放mp4文件的应用程序可以定义如下工厂：</p><figure class="highlight haxe"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Mp4ExtractorsFactory</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">ExtractorsFactory</span></span> </span>{</span><br><span class="line">  @Override</span><br><span class="line">  <span class="keyword">public</span> Extractor[] createExtractors() {</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Extractor</span>[] {<span class="keyword">new</span> <span class="type">Mp4Extractor</span>()};</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>并在实例化<code>ProgressiveMediaSource</code>实例时使用它，例如：</p><figure class="highlight haxe"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">ProgressiveMediaSource</span>.Factory(</span><br><span class="line">        mediaDataSourceFactory, <span class="keyword">new</span> <span class="type">Mp4ExtractorsFactory</span>())</span><br><span class="line">    .createMediaSource(uri);</span><br></pre></td></tr></tbody></table></figure><p>这将允许<code>ExtractorProGuard</code>删除其他实现，这可以显着减小大小。</p><h2 id="3、指定您的应用需要哪些渲染器"><a href="#3、指定您的应用需要哪些渲染器" class="headerlink" title="3、指定您的应用需要哪些渲染器"></a>3、指定您的应用需要哪些渲染器</h2><p>如果您的应用使用<code>SimpleExoPlayer</code>，请注意默认情况下将使用播放器的渲染器创建<code>DefaultRenderersFactory</code>。 <code>DefaultRenderersFactory</code>取决于ExoPlayer库中提供的所有<code>Renderer</code>实现，因此<code>ProGuard</code>不会删除它们。如果您知道您的应用只需要渲染器的子集，则可以指定自己的渲染器<code>RenderersFactory</code>。例如，只播放音频的应用可以定义工厂，如：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AudioOnlyRenderersFactory</span> <span class="keyword">implements</span> <span class="title">RenderersFactory</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Context context;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AudioOnlyRenderersFactory</span><span class="params">(Context context)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.context = context;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Renderer[] createRenderers(</span><br><span class="line">      Handler eventHandler,</span><br><span class="line">      VideoRendererEventListener videoRendererEventListener,</span><br><span class="line">      AudioRendererEventListener audioRendererEventListener,</span><br><span class="line">      TextOutput textRendererOutput,</span><br><span class="line">      MetadataOutput metadataRendererOutput,</span><br><span class="line">      DrmSessionManager&lt;FrameworkMediaCrypto&gt; drmSessionManager) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Renderer[] {<span class="keyword">new</span> MediaCodecAudioRenderer(</span><br><span class="line">        MediaCodecSelector.DEFAULT, eventHandler, audioRendererEventListener)};</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>并在实例化<code>SimpleExoPlayer</code>实例时使用它，例如：</p><figure class="highlight haxe"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SimpleExoPlayer player = ExoPlayerFactory.<span class="keyword">new</span><span class="type">SimpleInstance</span>(</span><br><span class="line">    context, <span class="keyword">new</span> <span class="type">AudioOnlyRenderersFactory</span>(context), trackSelector);</span><br></pre></td></tr></tbody></table></figure><p>这将允许<code>ProGuard</code>删除其<code>Renderer</code>他实现。在此特定示例中，视频，文本和元数据渲染器将被删除。</p><hr><hr><h1 id="六、OEM测试"><a href="#六、OEM测试" class="headerlink" title="六、OEM测试"></a>六、OEM测试</h1><p>ExoPlayer被大量Android应用程序使用。作为OEM，确保ExoPlayer在新设备和现有设备的新平台构建上都能正常工作非常重要。此页面介绍了我们建议在运送设备或平台OTA之前运行的兼容性测试，以及运行它们时遇到的一些常见故障模式。</p><h2 id="1、运行测试"><a href="#1、运行测试" class="headerlink" title="1、运行测试"></a>1、运行测试</h2><p>要运行ExoPlayer的回放测试，首先从GitHub查看最新版本的ExoPlayer 。然后，您可以从命令行或Android Studio运行测试。</p><h3 id="（1）、命令行"><a href="#（1）、命令行" class="headerlink" title="（1）、命令行"></a>（1）、命令行</h3><p>从根目录，构建并安装回放测试：</p><figure class="highlight elixir"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew <span class="symbol">:playbacktests</span><span class="symbol">:installDebug</span></span><br></pre></td></tr></tbody></table></figure><p>接下来，在GTS包中运行回放测试：</p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb shell am instrument -w -r -e debug false \</span><br><span class="line">  -e package com<span class="selector-class">.google</span><span class="selector-class">.android</span><span class="selector-class">.exoplayer2</span><span class="selector-class">.playbacktests</span><span class="selector-class">.gts</span> \</span><br><span class="line">  com<span class="selector-class">.google</span><span class="selector-class">.android</span><span class="selector-class">.exoplayer2</span><span class="selector-class">.playbacktests</span><span class="selector-class">.test</span>/android<span class="selector-class">.test</span><span class="selector-class">.InstrumentationTestRunner</span></span><br></pre></td></tr></tbody></table></figure><p>测试结果显示在STDOUT中。</p><h3 id="（2）、Android-Studio"><a href="#（2）、Android-Studio" class="headerlink" title="（2）、Android Studio"></a>（2）、Android Studio</h3><p>打开ExoPlayer项目，导航到该<code>playbacktests</code>模块，右键单击该<code>gts</code>文件夹并运行测试。测试结果显示在Android Studio的“运行”窗口中。</p><h2 id="2、常见故障模式"><a href="#2、常见故障模式" class="headerlink" title="2、常见故障模式"></a>2、常见故障模式</h2><p>下面介绍运行ExoPlayer播放测试时遇到的一些常见故障模式，以及每种情况下可能的根本原因。我们将添加到此列表中，因为会发现更多故障模式。</p><h3 id="（1）、意外的视频缓冲区演示时间戳"><a href="#（1）、意外的视频缓冲区演示时间戳" class="headerlink" title="（1）、意外的视频缓冲区演示时间戳"></a>（1）、意外的视频缓冲区演示时间戳</h3><p>Logcat将包含类似于的错误：</p><figure class="highlight vim"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.IllegalStateException: Expected <span class="keyword">to</span> dequeue video <span class="keyword">buffer</span></span><br><span class="line">with presentation timestamp: <span class="number">134766000</span>. Instead <span class="keyword">go</span><span class="variable">t:</span> <span class="number">134733000</span> (Processed</span><br><span class="line"><span class="keyword">buffers</span> since <span class="keyword">last</span> flush: <span class="number">2242</span>).</span><br></pre></td></tr></tbody></table></figure><p>这种故障通常是由于被测视频解码器错误地丢弃，插入或重新排序缓冲区引起的。在上面的示例中，测试期望134766000从<code>MediaCodec.dequeueOutputBuffer</code>具有显示时间戳的缓冲区出列 ，但发现它使用呈现时间戳使缓冲区出列134733000。我们建议您在遇到此故障时检查解码器实现，特别是它正确处理自适应分辨率开关而不丢弃任何缓冲区。</p><h3 id="（2）、丢失的缓冲区太多了"><a href="#（2）、丢失的缓冲区太多了" class="headerlink" title="（2）、丢失的缓冲区太多了"></a>（2）、丢失的缓冲区太多了</h3><p>Logcat将包含类似于的错误：</p><figure class="highlight groovy"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">junit.framework.<span class="string">AssertionFailedError:</span> Codec(<span class="string">DashTest:</span>Video) was late <span class="string">decoding:</span></span><br><span class="line"><span class="number">200</span> buffers. <span class="string">Limit:</span> <span class="number">25.</span></span><br></pre></td></tr></tbody></table></figure><p>这种故障是性能问题，其中被测视频解码器对大量缓冲器进行后期解码。在上面的示例中，ExoPlayer丢弃了200个缓冲区，因为它们在出列时已经迟到了，对于一个限制为25的测试。最明显的原因是视频解码器解码缓冲区太慢。如果故障仅发生在播放Widevine受保护内容的测试子集中，则缓冲区解密的平台操作可能太慢。我们建议检查这些组件的性能，并查看是否可以进行任何优化以加快它们的速度。</p><h3 id="（3）、无法验证本机窗口"><a href="#（3）、无法验证本机窗口" class="headerlink" title="（3）、无法验证本机窗口"></a>（3）、无法验证本机窗口</h3><p>Logcat将包含类似于的错误：</p><figure class="highlight vim"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SurfaceUtil<span class="variable">s:</span> native window could not <span class="keyword">be</span> authenticated</span><br><span class="line">ExoPlayerImplInterna<span class="variable">l:</span> Internal <span class="keyword">runtime</span> error.</span><br><span class="line">ExoPlayerImplInterna<span class="variable">l:</span> android.media.MediaCodec$CodecException: Error <span class="number">0</span>xffffffff</span><br></pre></td></tr></tbody></table></figure><p>此失败表示平台未能正确设置安全位标志。</p><h3 id="（4）、测试超时"><a href="#（4）、测试超时" class="headerlink" title="（4）、测试超时"></a>（4）、测试超时</h3><p>Logcat将包含类似于的错误：</p><figure class="highlight avrasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">AssertionFailedError:</span> Test timed <span class="keyword">out</span> after <span class="number">300000</span> ms.</span><br></pre></td></tr></tbody></table></figure><p>此故障通常是由测试运行期间网络连接不良引起的。如果设备出现有良好的网络连接，然后它可能是在测试卡住调用到一个平台组件（例如 <code>MediaCodec</code>，<code>MediaDrm</code>，<code>AudioTrack</code>等）。检查测试过程中线程的调用堆栈以确定是否是这种情况。</p><hr><hr><h1 id="七、设计RFC状态的文档"><a href="#七、设计RFC状态的文档" class="headerlink" title="七、设计RFC状态的文档"></a>七、设计RFC状态的文档</h1><ul><li><a href="https://docs.google.com/document/d/11h0S91KI5TB3NNZUtsCzg0S7r6nyTnF_tDZZAtmY93g" target="_blank" rel="noopener">播放列表API</a>（2019年7月）</li><li><a href="https://docs.google.com/document/d/1e3jVkZ6nxNWgCqTNibqV8uJcKo8d597XVl3nJkY7P8c" target="_blank" rel="noopener">带宽估算分析</a>（2019年7月）</li></ul><hr><hr><hr><blockquote><p>转载此文请标明出处：<a href="https://blog.csdn.net/MRYZJ/article/details/98657228" target="_blank" rel="noopener">https://blog.csdn.net/MRYZJ/article/details/98657228</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
          <category> ExoPlayer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> ExoPlayer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ExoPlayer详解——媒体类型（官方文档）</title>
      <link href="/undefined/92fbeb27.html"/>
      <url>/undefined/92fbeb27.html</url>
      
        <content type="html"><![CDATA[<p>﻿&gt;  #####  ExoPlayer详解系列文章</p><blockquote><ul><li><a href="https://blog.csdn.net/MRYZJ/article/details/98657228" target="_blank" rel="noopener">ExoPlayer详解——入门（官方文档）</a></li><li><a href="https://blog.csdn.net/MRYZJ/article/details/98759532" target="_blank" rel="noopener">ExoPlayer详解——媒体类型（官方文档）</a></li><li><a href="https://blog.csdn.net/MRYZJ/article/details/98853258" target="_blank" rel="noopener">ExoPlayer详解——高级主题（官方文档）</a></li></ul></blockquote><h1 id="一、DASH"><a href="#一、DASH" class="headerlink" title="一、DASH"></a>一、DASH</h1><p>ExoPlayer支持多种容器格式的DASH。必须对媒体流进行解复用，这意味着必须在DASH清单中的不同AdaptationSet元素中定义视频，音频和文本（CEA-608是一个例外，如下表所述）。还必须支持包含的音频和视频样本格式（有关详细信息，请参阅 <a href="https://exoplayer.dev/supported-formats.html#sample-formats" target="_blank" rel="noopener">示例格式</a>部分）。</p><table><thead><tr><th align="left"><font color="black"><strong>特征</strong></font></th><th><font color="black"><strong>支持</strong></font></th><th align="left"><font color="black"><strong>评论</strong></font></th></tr></thead><tbody><tr><td align="left"><font color="black"><strong>集装箱</strong></font></td><td></td><td align="left"></td></tr><tr><td align="left">FMP4</td><td>是</td><td align="left">仅拆分流</td></tr><tr><td align="left">WebM</td><td>是</td><td align="left">仅拆分流</td></tr><tr><td align="left">Matroska</td><td>是</td><td align="left">仅拆分流</td></tr><tr><td align="left">MPEG-TS</td><td>否</td><td align="left">没有支持计划</td></tr><tr><td align="left"><font color="black"><strong>隐藏式字幕/字幕</strong></font></td><td></td><td align="left"></td></tr><tr><td align="left">TTML</td><td>是</td><td align="left">根据ISO / IEC 14496-30原始或嵌入FMP4中</td></tr><tr><td align="left">WebVTT</td><td>是</td><td align="left">根据ISO / IEC 14496-30原始或嵌入FMP4中</td></tr><tr><td align="left">CEA-608</td><td>是</td><td align="left">携带在FMP4视频流中嵌入的SEI消息</td></tr><tr><td align="left"><font color="black"><strong>元数据</strong></font></td><td></td><td align="left"></td></tr><tr><td align="left">EMSG元数据</td><td>是</td><td align="left">嵌入在FMP4中</td></tr><tr><td align="left"><font color="black"><strong>内容保护</strong></font></td><td></td><td align="left"></td></tr><tr><td align="left">Widevine</td><td>是</td><td align="left">API 19+（“cenc”方案）和25+（“cbcs”，“cbc1”和“cens”方案）</td></tr><tr><td align="left">PlayReady SL2000</td><td>是</td><td align="left">仅限Android TV</td></tr><tr><td align="left">ClearKey</td><td>是</td><td align="left">API 21+</td></tr></tbody></table><h2 id="1、创建MediaSource"><a href="#1、创建MediaSource" class="headerlink" title="1、创建MediaSource"></a>1、创建MediaSource</h2><p>要播放DASH流，请<code>DashMediaSource</code>像往常一样创建并准备播放器。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">Create</span> a <span class="keyword">data</span> <span class="keyword">source</span> factory.</span><br><span class="line">DataSource.Factory dataSourceFactory =</span><br><span class="line">    <span class="keyword">new</span> DefaultHttpDataSourceFactory(Util.getUserAgent(<span class="keyword">context</span>, <span class="string">"app-name"</span>));</span><br><span class="line">// <span class="keyword">Create</span> a DASH media <span class="keyword">source</span> pointing <span class="keyword">to</span> a DASH manifest uri.</span><br><span class="line">MediaSource mediaSource = <span class="keyword">new</span> DashMediaSource.Factory(dataSourceFactory)</span><br><span class="line">    .createMediaSource(dashUri);</span><br><span class="line">// <span class="keyword">Create</span> a player instance.</span><br><span class="line">SimpleExoPlayer player = ExoPlayerFactory.newSimpleInstance(<span class="keyword">context</span>);</span><br><span class="line">// <span class="keyword">Prepare</span> the player <span class="keyword">with</span> the DASH media source.</span><br><span class="line">player.prepare(mediaSource);</span><br></pre></td></tr></tbody></table></figure><p>ExoPlayer将自动调整清单中定义的表示，同时考虑可用带宽和设备功能。</p><h2 id="2、访问清单"><a href="#2、访问清单" class="headerlink" title="2、访问清单"></a>2、访问清单</h2><p>您可以通过调用<code>Player.getCurrentManifest</code>来检索当前清单。对于DASH，您应该将返回的对象强制转换为<code>DashManifest</code>。该<code>onTimelineChanged</code>回调<code>Player.EventListener</code>也被称为清单加载。对于点播内容，这将发生一次，对于直播内容可能会发生多次。下面的代码片段显示了应用程序在加载清单时如何执行操作。</p><figure class="highlight d"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">player.addListener(</span><br><span class="line">    <span class="keyword">new</span> Player.EventListener() {</span><br><span class="line">      <span class="keyword">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> onTimelineChanged(</span><br><span class="line">          Timeline timeline,</span><br><span class="line">          <span class="keyword">@Nullable</span> Object manifest,</span><br><span class="line">          <span class="keyword">@Player</span>.TimelineChangeReason <span class="keyword">int</span> reason) {</span><br><span class="line">        <span class="keyword">if</span> (manifest != <span class="literal">null</span>) {</span><br><span class="line">          DashManifest dashManifest = (DashManifest) manifest;</span><br><span class="line">          <span class="comment">// Do something with the manifest.</span></span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    });</span><br></pre></td></tr></tbody></table></figure><h2 id="3、侧载清单"><a href="#3、侧载清单" class="headerlink" title="3、侧载清单"></a>3、侧载清单</h2><p>对于特定用例，有一种替代方法可以通过将<code>DashManifest</code>对象传递给构造函数来提供清单。</p><figure class="highlight haxe"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DataSource.Factory dataSourceFactory =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">DefaultHttpDataSourceFactory</span>(Util.getUserAgent(context, <span class="string">"app-name"</span>));</span><br><span class="line"><span class="comment">// Create a dash media source with a dash manifest.</span></span><br><span class="line">MediaSource mediaSource = <span class="keyword">new</span> <span class="type">DashMediaSource</span>.Factory(dataSourceFactory)</span><br><span class="line">    .createMediaSource(dashManifest);</span><br><span class="line"><span class="comment">// Create a player instance which gets an adaptive track selector by default.</span></span><br><span class="line">SimpleExoPlayer player = ExoPlayerFactory.<span class="keyword">new</span><span class="type">SimpleInstance</span>(context);</span><br><span class="line"><span class="comment">// Prepare the player with the dash media source.</span></span><br><span class="line">player.prepare(mediaSource);</span><br></pre></td></tr></tbody></table></figure><h2 id="4、自定义DASH播放"><a href="#4、自定义DASH播放" class="headerlink" title="4、自定义DASH播放"></a>4、自定义DASH播放</h2><p>ExoPlayer提供多种方式让您根据应用的需求定制播放体验。以下部分简要介绍了构建<code>DashMediaSource</code>时可用的一些自定义选项。有关更多常规自定义选项，请参阅<a href="https://exoplayer.dev/customization.html" target="_blank" rel="noopener">“ 自定义”页面</a>。</p><h3 id="（1）、自定义服务器交互"><a href="#（1）、自定义服务器交互" class="headerlink" title="（1）、自定义服务器交互"></a>（1）、自定义服务器交互</h3><p>某些应用可能希望拦截HTTP请求和响应。您可能希望注入自定义请求标头，读取服务器的响应标头，修改请求的URI等。例如，您的应用程序可以通过在请求媒体段时将标记作为标头注入来验证自身。您可以通过将自定义<a href="https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/upstream/HttpDataSource.html" target="_blank" rel="noopener">HttpDataSources</a>注入到你创建的<code>DashMediaSource</code>中来实现这些行为。以下代码段显示了标头注入的示例：</p><figure class="highlight haxe"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DashMediaSource dashMediaSource =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">DashMediaSource</span>.Factory(</span><br><span class="line">            () -&gt; {</span><br><span class="line">              HttpDataSource dataSource = <span class="keyword">new</span> <span class="type">DefaultHttpDataSource</span>(userAgent);</span><br><span class="line">              <span class="comment">// Set a custom authentication request header.</span></span><br><span class="line">              dataSource.setRequestProperty(<span class="string">"Header"</span>, <span class="string">"Value"</span>);</span><br><span class="line">              <span class="keyword">return</span> dataSource;</span><br><span class="line">            })</span><br><span class="line">        .createMediaSource(dashUri);</span><br></pre></td></tr></tbody></table></figure><h3 id="（2）、自定义错误处理"><a href="#（2）、自定义错误处理" class="headerlink" title="（2）、自定义错误处理"></a>（2）、自定义错误处理</h3><p>实现自定义<a href="https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/upstream/LoadErrorHandlingPolicy.html" target="_blank" rel="noopener">LoadErrorHandlingPolicy</a>允许应用程序自定义ExoPlayer对加载错误的反应方式。例如，应用程序可能希望快速失败而不是多次重试，或者可能想要自定义控制player在每次重试之间等待多长时间的退避逻辑。以下代码段显示了在创建<code>DashMediaSource</code>以下内容时如何实现自定义退避逻辑：</p><figure class="highlight aspectj"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DashMediaSource dashMediaSource =</span><br><span class="line">    <span class="keyword">new</span> DashMediaSource.Factory(dataSourceFactory)</span><br><span class="line">        .setLoadErrorHandlingPolicy(</span><br><span class="line">            <span class="keyword">new</span> DefaultLoadErrorHandlingPolicy() {</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="keyword">public</span> <span class="function"><span class="keyword">long</span> <span class="title">getRetryDelayMsFor</span><span class="params">(...)</span> </span>{</span><br><span class="line">                <span class="comment">// Implement custom back-off logic here.</span></span><br><span class="line">              }</span><br><span class="line">            })</span><br><span class="line">        .createMediaSource(dashUri);</span><br></pre></td></tr></tbody></table></figure><p>您可以在我们的媒体帖子中找到有关<a href="https://medium.com/google-exoplayer/load-error-handling-in-exoplayer-488ab6908137" target="_blank" rel="noopener">错误处理</a>的更多信息。</p><h2 id="5、BehindLiveWindowException"><a href="#5、BehindLiveWindowException" class="headerlink" title="5、BehindLiveWindowException"></a>5、BehindLiveWindowException</h2><p>在播放具有有限可用性的直播流的情况下，如果播放器暂停或缓冲足够长的时间段，则播放器可能落后于该实况窗口。在这种情况下，抛出一个<code>BehindLiveWindowException</code>，可以捕获它并在现场边缘恢复player。演示应用程序的<a href="https://github.com/google/ExoPlayer/tree/release-v2/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java" target="_blank" rel="noopener">PlayerActivity</a>举例说明了这种方法。</p><figure class="highlight aspectj"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onPlayerError</span><span class="params">(ExoPlaybackException e)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (isBehindLiveWindow(e)) {</span><br><span class="line">    <span class="comment">// Re-initialize player at the live edge.</span></span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">// Handle other errors</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isBehindLiveWindow</span><span class="params">(ExoPlaybackException e)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (e.type != ExoPlaybackException.TYPE_SOURCE) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  }</span><br><span class="line">  Throwable cause = e.getSourceException();</span><br><span class="line">  <span class="keyword">while</span> (cause != <span class="keyword">null</span>) {</span><br><span class="line">    <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> BehindLiveWindowException) {</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    cause = cause.getCause();</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><hr><h1 id="二、HLS"><a href="#二、HLS" class="headerlink" title="二、HLS"></a>二、HLS</h1><p>ExoPlayer支持多种容器格式的HLS。还必须支持包含的音频和视频样本格式（有关详细信息，请参阅 示例格式部分）。我们强烈鼓励HLS内容制作产生高品质的HLS流，描述 在这里。</p><table><thead><tr><th align="left"><font color="black"><strong>特征</strong></font></th><th><font color="black"><strong>支持</strong></font></th><th align="left"><font color="black"><strong>评论</strong></font></th></tr></thead><tbody><tr><td align="left"><font color="black"><strong>集装箱</strong></font></td><td></td><td align="left"></td></tr><tr><td align="left">MPEG-TS</td><td>是</td><td align="left"></td></tr><tr><td align="left">FMP4 / CMAF</td><td>是</td><td align="left"></td></tr><tr><td align="left">ADTS（AAC）</td><td>是</td><td align="left"></td></tr><tr><td align="left">MP3</td><td>是</td><td align="left"></td></tr><tr><td align="left"><font color="black"><strong>隐藏式字幕/字幕</strong></font></td><td></td><td align="left"></td></tr><tr><td align="left">CEA-608</td><td>是</td><td align="left"></td></tr><tr><td align="left">WebVTT</td><td>是</td><td align="left"></td></tr><tr><td align="left"><font color="black"><strong>元数据</strong></font></td><td></td><td align="left"></td></tr><tr><td align="left">ID3元数据</td><td>是</td><td align="left"></td></tr><tr><td align="left"><font color="black"><strong>内容保护</strong></font></td><td></td><td align="left"></td></tr><tr><td align="left">AES-128</td><td>是</td><td align="left"></td></tr><tr><td align="left">样品AES-128</td><td>没有</td><td align="left"></td></tr><tr><td align="left">Widevine</td><td>是</td><td align="left">API 19+（“cenc”方案）和25+（“cbcs”方案）</td></tr><tr><td align="left">PlayReady SL2000</td><td>是</td><td align="left">仅限Android TV</td></tr></tbody></table><h2 id="1、创建MediaSource-1"><a href="#1、创建MediaSource-1" class="headerlink" title="1、创建MediaSource"></a>1、创建MediaSource</h2><p>要播放HLS流，请像往常一样创建<code>HlsMediaSource</code>并准备播放器。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">Create</span> a <span class="keyword">data</span> <span class="keyword">source</span> factory.</span><br><span class="line">DataSource.Factory dataSourceFactory =</span><br><span class="line">    <span class="keyword">new</span> DefaultHttpDataSourceFactory(Util.getUserAgent(<span class="keyword">context</span>, <span class="string">"app-name"</span>));</span><br><span class="line">// <span class="keyword">Create</span> a HLS media <span class="keyword">source</span> pointing <span class="keyword">to</span> a playlist uri.</span><br><span class="line">HlsMediaSource hlsMediaSource =</span><br><span class="line">    <span class="keyword">new</span> HlsMediaSource.Factory(dataSourceFactory).createMediaSource(uri);</span><br><span class="line">// <span class="keyword">Create</span> a player instance.</span><br><span class="line">SimpleExoPlayer player = ExoPlayerFactory.newSimpleInstance(<span class="keyword">context</span>);</span><br><span class="line">// <span class="keyword">Prepare</span> the player <span class="keyword">with</span> the HLS media source.</span><br><span class="line">player.prepare(hlsMediaSource);</span><br></pre></td></tr></tbody></table></figure><p>URI传递给<code>HlsMediaSource.Factory.createMediaSource()</code>可以指向媒体播放列表或主播放列表。如果URI指向声明多个<code>#EXT-X-STREAM-INF</code>标签的主播放列表，则ExoPlayer将自动调整变体，同时考虑可用带宽和设备功能。</p><h2 id="2、自定义HLS播放"><a href="#2、自定义HLS播放" class="headerlink" title="2、自定义HLS播放"></a>2、自定义HLS播放</h2><p>ExoPlayer提供多种方式让您根据应用的需求定制播放体验。以下部分简要介绍了构建<code>HlsMediaSource</code>时可用的一些自定义选项。有关更多常规自定义选项，请参阅<a href="https://exoplayer.dev/customization.html" target="_blank" rel="noopener">“自定义”页面</a>。</p><h3 id="（1）、启用更快的启动时间"><a href="#（1）、启用更快的启动时间" class="headerlink" title="（1）、启用更快的启动时间"></a>（1）、启用更快的启动时间</h3><p>通过启用无块准备，您可以显着提高HLS启动时间。当您启用无块准备并且<code>#EXT-X-STREAM-INF</code>标签包含该 <code>CODECS</code>属性时，ExoPlayer将避免在准备过程中下载媒体段。以下代码段显示了如何启用无块准备：</p><figure class="highlight jboss-cli"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">H<span class="keyword">ls</span>MediaSource hlsMediaSource =</span><br><span class="line">    new H<span class="keyword">ls</span>MediaSource.Factory<span class="params">(dataSourceFactory)</span></span><br><span class="line">        <span class="string">.setAllowChunklessPreparation</span><span class="params">(true)</span></span><br><span class="line">        <span class="string">.createMediaSource</span><span class="params">(hlsUri)</span>;</span><br></pre></td></tr></tbody></table></figure><p>您可以在我们的关于无框准备的媒体帖子中找到更多详细信息。</p><h3 id="（2）、自定义服务器交互"><a href="#（2）、自定义服务器交互" class="headerlink" title="（2）、自定义服务器交互"></a>（2）、自定义服务器交互</h3><p>某些应用可能希望拦截HTTP请求和响应。您可能希望注入自定义请求标头，读取服务器的响应标头，修改请求的URI等。例如，您的应用程序可以通过在访问媒体段的URI中注入自定义标记来验证自身。您可以通过将自定义<a href="https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/upstream/HttpDataSource.html" target="_blank" rel="noopener">HttpDataSources</a>注入到创建的<code>HlsMediaSource</code>中来实现这些行为。以下代码段显示了请求标头注入的示例：</p><figure class="highlight haxe"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HlsMediaSource hlsMediaSource =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">HlsMediaSource</span>.Factory(</span><br><span class="line">            dataType -&gt; {</span><br><span class="line">              HttpDataSource dataSource =</span><br><span class="line">                  <span class="keyword">new</span> <span class="type">DefaultHttpDataSource</span>(userAgent);</span><br><span class="line">              <span class="keyword">if</span> (dataType == C.DATA_TYPE_MEDIA) {</span><br><span class="line">                <span class="comment">// The data source will be used for fetching media segments. We</span></span><br><span class="line">                <span class="comment">// set a custom authentication request header.</span></span><br><span class="line">                dataSource.setRequestProperty(<span class="string">"Header"</span>, <span class="string">"Value"</span>);</span><br><span class="line">              }</span><br><span class="line">              <span class="keyword">return</span> dataSource;</span><br><span class="line">            })</span><br><span class="line">        .createMediaSource(hlsUri);</span><br></pre></td></tr></tbody></table></figure><h3 id="（3）、自定义错误处理"><a href="#（3）、自定义错误处理" class="headerlink" title="（3）、自定义错误处理"></a>（3）、自定义错误处理</h3><p>实现自定义<a href="https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/upstream/LoadErrorHandlingPolicy.html" target="_blank" rel="noopener">LoadErrorHandlingPolicy</a>允许应用程序自定义ExoPlayer对加载错误的反应方式。例如，应用程序可能希望快速失败而不是多次重试，或者可能想要自定义控制player在每次重试之间等待多长时间的退避逻辑。以下代码段显示了在创建以下<code>HlsMediaSource</code>内容时如何实现自定义退避逻辑：</p><figure class="highlight aspectj"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HlsMediaSource hlsMediaSource =</span><br><span class="line">    <span class="keyword">new</span> HlsMediaSource.Factory(dataSourceFactory)</span><br><span class="line">        .setLoadErrorHandlingPolicy(</span><br><span class="line">            <span class="keyword">new</span> DefaultLoadErrorHandlingPolicy() {</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="keyword">public</span> <span class="function"><span class="keyword">long</span> <span class="title">getRetryDelayMsFor</span><span class="params">(...)</span> </span>{</span><br><span class="line">                <span class="comment">// Implement custom back-off logic here.</span></span><br><span class="line">              }</span><br><span class="line">            })</span><br><span class="line">        .createMediaSource(hlsUri);</span><br></pre></td></tr></tbody></table></figure><p>您可以在我们的媒体帖子中找到有关<a href="https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/upstream/LoadErrorHandlingPolicy.html" target="_blank" rel="noopener">错误处理的更多信息</a>。</p><h2 id="3、创建高质量的HLS内容"><a href="#3、创建高质量的HLS内容" class="headerlink" title="3、创建高质量的HLS内容"></a>3、创建高质量的HLS内容</h2><p>为了充分利用ExoPlayer，您可以遵循某些指导原则来改进您的HLS内容。阅读我们<a href="https://medium.com/google-exoplayer/hls-playback-in-exoplayer-a33959a47be7" target="_blank" rel="noopener">在ExoPlayer中关于HLS播放的媒体帖子</a>，以获得完整的解释。要点是：</p><ul><li>使用精确的段持续时间。</li><li>使用连续媒体流; 避免跨段的媒体结构的变化。</li><li>使用<code>#EXT-X-INDEPENDENT-SEGMENTS</code>标签。</li><li>更喜欢分离的流，而不是包含视频和音频的文件。</li><li>包括主播放列表中的所有信息。</li></ul><p>以下指南专门适用于直播流：</p><ul><li>使用<code>#EXT-X-PROGRAM-DATE-TIME</code>标签。</li><li>使用<code>#EXT-X-DISCONTINUITY-SEQUENCE</code>标签。</li><li>提供一个长时间存在的窗口。一分钟或时间越长越好。</li></ul><h2 id="4、BehindLiveWindowException"><a href="#4、BehindLiveWindowException" class="headerlink" title="4、BehindLiveWindowException"></a>4、BehindLiveWindowException</h2><p>在播放具有有限可用性的直播流的情况下，如果播放器暂停或缓冲足够长的时间段，则播放器可能落后于该实况窗口。在这种情况下，抛出一个<code>BehindLiveWindowException</code>，可以捕获它并在现场边缘恢复player。演示应用程序的<a href="https://github.com/google/ExoPlayer/tree/release-v2/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java" target="_blank" rel="noopener">PlayerActivity</a>举例说明了这种方法。</p><figure class="highlight aspectj"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onPlayerError</span><span class="params">(ExoPlaybackException e)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (isBehindLiveWindow(e)) {</span><br><span class="line">    <span class="comment">// Re-initialize player at the live edge.</span></span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">// Handle other errors</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isBehindLiveWindow</span><span class="params">(ExoPlaybackException e)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (e.type != ExoPlaybackException.TYPE_SOURCE) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  }</span><br><span class="line">  Throwable cause = e.getSourceException();</span><br><span class="line">  <span class="keyword">while</span> (cause != <span class="keyword">null</span>) {</span><br><span class="line">    <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> BehindLiveWindowException) {</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    cause = cause.getCause();</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><hr><h1 id="三、Smoothtreaming"><a href="#三、Smoothtreaming" class="headerlink" title="三、Smoothtreaming"></a>三、Smoothtreaming</h1><p>ExoPlayer支持使用FMP4容器格式的SmoothStreaming。必须对媒体流进行解复用，这意味着必须在SmoothStreaming清单中的不同StreamIndex元素中定义视频，音频和文本。还必须支持包含的音频和视频样本格式（有关详细信息，请参阅 <a href="https://exoplayer.dev/supported-formats.html#sample-formats" target="_blank" rel="noopener">示例格式</a>部分）。</p><table><thead><tr><th align="left"><font color="black"><strong>特征</strong></font></th><th><font color="black"><strong>支持</strong></font></th><th align="left"><font color="black"><strong>评论</strong></font></th></tr></thead><tbody><tr><td align="left"><font color="black"><strong>集装箱</strong></font></td><td></td><td align="left"></td></tr><tr><td align="left">FMP4</td><td>是</td><td align="left">仅拆分流</td></tr><tr><td align="left"><font color="black"><strong>隐藏式字幕/字幕</strong></font></td><td></td><td align="left"></td></tr><tr><td align="left">TTML</td><td>是</td><td align="left">嵌入在FMP4中</td></tr><tr><td align="left"><font color="black"><strong>内容保护</strong></font></td><td></td><td align="left"></td></tr><tr><td align="left">PlayReady SL2000</td><td>是</td><td align="left">仅限Android TV</td></tr></tbody></table><h2 id="1、创建媒体源"><a href="#1、创建媒体源" class="headerlink" title="1、创建媒体源"></a>1、创建媒体源</h2><p>要播放<code>SmoothStreaming</code>流，请像往常一样使用它创建<code>SsMediaSource</code>并准备播放器。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">Create</span> a <span class="keyword">data</span> <span class="keyword">source</span> factory.</span><br><span class="line">DataSource.Factory dataSourceFactory =</span><br><span class="line">    <span class="keyword">new</span> DefaultHttpDataSourceFactory(Util.getUserAgent(<span class="keyword">context</span>, <span class="string">"app-name"</span>));</span><br><span class="line">// <span class="keyword">Create</span> a SmoothStreaming media <span class="keyword">source</span> pointing <span class="keyword">to</span> a manifest uri.</span><br><span class="line">MediaSource mediaSource =</span><br><span class="line">    <span class="keyword">new</span> SsMediaSource.Factory(dataSourceFactory).createMediaSource(ssUri);</span><br><span class="line">// <span class="keyword">Create</span> a player instance.</span><br><span class="line">SimpleExoPlayer player = ExoPlayerFactory.newSimpleInstance(<span class="keyword">context</span>);</span><br><span class="line">// <span class="keyword">Prepare</span> the player <span class="keyword">with</span> the SmoothStreaming media source.</span><br><span class="line">player.prepare(mediaSource);</span><br></pre></td></tr></tbody></table></figure><p>ExoPlayer将自动调整清单中定义的流，同时考虑可用带宽和设备功能。</p><h2 id="2、访问清单-1"><a href="#2、访问清单-1" class="headerlink" title="2、访问清单"></a>2、访问清单</h2><p>您可以通过调用来检索当前清单Player.getCurrentManifest。对于SmoothStreaming，您应该将返回的对象强制转换为SsManifest。该 onTimelineChanged回调Player.EventListener每当清单加载也被称为。对于点播内容，这将发生一次，对于直播内容可能会发生多次。下面的代码片段显示了应用程序在加载清单时如何执行操作。</p><figure class="highlight d"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">player.addListener(</span><br><span class="line">    <span class="keyword">new</span> Player.EventListener() {</span><br><span class="line">      <span class="keyword">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> onTimelineChanged(</span><br><span class="line">          Timeline timeline,</span><br><span class="line">          <span class="keyword">@Nullable</span> Object manifest,</span><br><span class="line">          <span class="keyword">@Player</span>.TimelineChangeReason <span class="keyword">int</span> reason) {</span><br><span class="line">        <span class="keyword">if</span> (manifest != <span class="literal">null</span>) {</span><br><span class="line">          SsManifest ssManifest = (SsManifest) manifest;</span><br><span class="line">          <span class="comment">// Do something with the manifest.</span></span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    });</span><br></pre></td></tr></tbody></table></figure><h2 id="3、侧载清单-1"><a href="#3、侧载清单-1" class="headerlink" title="3、侧载清单"></a>3、侧载清单</h2><p>对于特定用例，有一种替代方法可以通过将SsManifest对象传递给构造函数来提供清单。</p><figure class="highlight haxe"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DataSource.Factory dataSourceFactory =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">DefaultHttpDataSourceFactory</span>(Util.getUserAgent(context, <span class="string">"app-name"</span>));</span><br><span class="line"><span class="comment">// Create a smooth streaming media source with a smooth streaming  manifest.</span></span><br><span class="line">MediaSource mediaSource =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">SsMediaSource</span>.Factory(dataSourceFactory).createMediaSource(ssManifest);</span><br><span class="line"><span class="comment">// Create a player instance which gets an adaptive track selector by default.</span></span><br><span class="line">SimpleExoPlayer player = ExoPlayerFactory.<span class="keyword">new</span><span class="type">SimpleInstance</span>(context);</span><br><span class="line"><span class="comment">// Prepare the player with the media source.</span></span><br><span class="line">player.prepare(mediaSource);</span><br></pre></td></tr></tbody></table></figure><h2 id="4、自定义SmoothStreaming回放"><a href="#4、自定义SmoothStreaming回放" class="headerlink" title="4、自定义SmoothStreaming回放"></a>4、自定义SmoothStreaming回放</h2><p>ExoPlayer提供多种方式让您根据应用的需求定制播放体验。以下部分简要介绍了构建<code>SsMediaSource</code>时可用的一些自定义选项。有关更多常规自定义选项，请参阅<a href="https://exoplayer.dev/customization.html" target="_blank" rel="noopener">“ 自定义”页面</a>。</p><h3 id="（1）、自定义服务器交互-1"><a href="#（1）、自定义服务器交互-1" class="headerlink" title="（1）、自定义服务器交互"></a>（1）、自定义服务器交互</h3><p>某些应用可能希望拦截HTTP请求和响应。您可能希望注入自定义请求标头，读取服务器的响应标头，修改请求的URI等。例如，您的应用程序可以通过在访问媒体段的URI中注入自定义标记来验证自身。您可以通过将自定义<a href="https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/upstream/HttpDataSource.html" target="_blank" rel="noopener">HttpDataSources</a>注入到创建的<code>SsMediaSource</code>中来实现这些行为。以下代码段显示了请求标头注入的示例：</p><figure class="highlight haxe"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SsMediaSource ssMediaSource =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">SsMediaSource</span>.Factory(</span><br><span class="line">            () -&gt; {</span><br><span class="line">              HttpDataSource dataSource = <span class="keyword">new</span> <span class="type">DefaultHttpDataSource</span>(userAgent);</span><br><span class="line">              <span class="comment">// Set a custom authentication request header.</span></span><br><span class="line">              dataSource.setRequestProperty(<span class="string">"Header"</span>, <span class="string">"Value"</span>);</span><br><span class="line">              <span class="keyword">return</span> dataSource;</span><br><span class="line">            })</span><br><span class="line">        .createMediaSource(ssUri);</span><br></pre></td></tr></tbody></table></figure><h3 id="（1）、自定义错误处理"><a href="#（1）、自定义错误处理" class="headerlink" title="（1）、自定义错误处理"></a>（1）、自定义错误处理</h3><p>实现自定义<a href="https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/upstream/LoadErrorHandlingPolicy.html" target="_blank" rel="noopener">LoadErrorHandlingPolicy</a>允许应用程序自定义ExoPlayer对加载错误的反应方式。例如，应用程序可能希望快速失败而不是多次重试，或者可能想要自定义控制player在每次重试之间等待多长时间的退避逻辑。以下代码段显示了在创建以下<code>SsMediaSource</code>内容时如何实现自定义退避逻辑：</p><figure class="highlight aspectj"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SsMediaSource ssMediaSource =</span><br><span class="line">    <span class="keyword">new</span> SsMediaSource.Factory(dataSourceFactory)</span><br><span class="line">        .setLoadErrorHandlingPolicy(</span><br><span class="line">            <span class="keyword">new</span> DefaultLoadErrorHandlingPolicy() {</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="keyword">public</span> <span class="function"><span class="keyword">long</span> <span class="title">getRetryDelayMsFor</span><span class="params">(...)</span> </span>{</span><br><span class="line">                <span class="comment">// Implement custom back-off logic here.</span></span><br><span class="line">              }</span><br><span class="line">            })</span><br><span class="line">        .createMediaSource(ssUri);</span><br></pre></td></tr></tbody></table></figure><p>您可以在我们的媒体帖子中找到有关<a href="https://medium.com/google-exoplayer/load-error-handling-in-exoplayer-488ab6908137" target="_blank" rel="noopener">错误处理</a>的更多信息。</p><h2 id="5、BehindLiveWindowException-1"><a href="#5、BehindLiveWindowException-1" class="headerlink" title="5、BehindLiveWindowException"></a>5、BehindLiveWindowException</h2><p>在播放具有有限可用性的直播流的情况下，如果播放器暂停或缓冲足够长的时间段，则播放器可能落后于该实况窗口。在这种情况下，抛出一个<code>BehindLiveWindowException</code>，可以捕获它并在现场边缘恢复player。演示应用程序的<a href="https://github.com/google/ExoPlayer/tree/release-v2/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java" target="_blank" rel="noopener">PlayerActivity</a>举例说明了这种方法。</p><figure class="highlight aspectj"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onPlayerError</span><span class="params">(ExoPlaybackException e)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (isBehindLiveWindow(e)) {</span><br><span class="line">    <span class="comment">// Re-initialize player at the live edge.</span></span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">// Handle other errors</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isBehindLiveWindow</span><span class="params">(ExoPlaybackException e)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (e.type != ExoPlaybackException.TYPE_SOURCE) {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  }</span><br><span class="line">  Throwable cause = e.getSourceException();</span><br><span class="line">  <span class="keyword">while</span> (cause != <span class="keyword">null</span>) {</span><br><span class="line">    <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> BehindLiveWindowException) {</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    cause = cause.getCause();</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></tbody></table></figure><hr><hr><h1 id="四、Progressive"><a href="#四、Progressive" class="headerlink" title="四、Progressive"></a>四、Progressive</h1><p>以下容器格式的流可以由ExoPlayer直接播放。还必须支持包含的音频和视频样本格式（有关详细信息，请参阅 <a href="https://exoplayer.dev/supported-formats.html#sample-formats" target="_blank" rel="noopener">示例格式</a>部分）。</p><table><thead><tr><th align="left">容器格式</th><th>支持</th><th align="left">评论</th></tr></thead><tbody><tr><td align="left">MP4</td><td>是</td><td align="left"></td></tr><tr><td align="left">M4A</td><td>是</td><td align="left"></td></tr><tr><td align="left">FMP4</td><td>是</td><td align="left"></td></tr><tr><td align="left">WebM</td><td>是</td><td align="left"></td></tr><tr><td align="left">Matroska</td><td>是</td><td align="left"></td></tr><tr><td align="left">MP3</td><td>是</td><td align="left">有些流只能使用恒定比特率寻求**</td></tr><tr><td align="left">Ogg</td><td>是</td><td align="left">包含Vorbis，Opus和Flac</td></tr><tr><td align="left">WAV</td><td>是</td><td align="left"></td></tr><tr><td align="left">MPEG-TS</td><td>是</td><td align="left"></td></tr><tr><td align="left">MPEG-PS</td><td>是</td><td align="left"></td></tr><tr><td align="left">FLV</td><td>是</td><td align="left">不可寻求*</td></tr><tr><td align="left">ADTS（AAC）</td><td>是</td><td align="left">只能使用恒定比特率寻求**</td></tr><tr><td align="left">Flac</td><td>是</td><td align="left">仅使用<a href="https://github.com/google/ExoPlayer/tree/release-v2/extensions/flac" target="_blank" rel="noopener">Flac扩展名</a></td></tr><tr><td align="left">AMR</td><td>是</td><td align="left">只能使用恒定比特率寻求**</td></tr></tbody></table><p>*寻求不受支持，因为容器不提供元数据（例如，样本索引）以允许媒体播放器以有效的方式执行搜索。如果需要寻求，我们建议使用更合适的容器格式。</p><p>**这些提取器具有<code>FLAG_ENABLE_CONSTANT_BITRATE_SEEKING</code>用于使用恒定比特率假设来实现近似搜索的标志。默认情况下不启用此功能。最简单的方法来启用此功能支持它的是使用所有提取 <code>DefaultExtractorsFactory.setConstantBitrateSeekingEnabled</code>，描述 <a href="https://exoplayer.dev/progressive.html#enabling-constant-bitrate-seeking" target="_blank" rel="noopener">在这里</a>。</p><h2 id="1、创建MediaSource-2"><a href="#1、创建MediaSource-2" class="headerlink" title="1、创建MediaSource"></a>1、创建MediaSource</h2><p>要播放渐进流，请像往常一样创建<code>ProgressiveMediaSource</code>并准备播放器。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">Create</span> a <span class="keyword">data</span> <span class="keyword">source</span> factory.</span><br><span class="line">DataSource.Factory dataSourceFactory =</span><br><span class="line">    <span class="keyword">new</span> DefaultHttpDataSourceFactory(Util.getUserAgent(<span class="keyword">context</span>, <span class="string">"app-name"</span>));</span><br><span class="line">// <span class="keyword">Create</span> a progressive media <span class="keyword">source</span> pointing <span class="keyword">to</span> a stream uri.</span><br><span class="line">MediaSource mediaSource = <span class="keyword">new</span> ProgressiveMediaSource.Factory(dataSourceFactory)</span><br><span class="line">    .createMediaSource(progressiveUri);</span><br><span class="line">// <span class="keyword">Create</span> a player instance.</span><br><span class="line">SimpleExoPlayer player = ExoPlayerFactory.newSimpleInstance(<span class="keyword">context</span>);</span><br><span class="line">// <span class="keyword">Prepare</span> the player <span class="keyword">with</span> the progressive media source.</span><br><span class="line">player.prepare(mediaSource);</span><br></pre></td></tr></tbody></table></figure><h2 id="2、自定义渐进式播放"><a href="#2、自定义渐进式播放" class="headerlink" title="2、自定义渐进式播放"></a>2、自定义渐进式播放</h2><p>ExoPlayer提供多种方式让您根据应用的需求定制播放体验。以下部分简要介绍了构建<code>ProgressiveMediaSource</code>时可用的一些自定义选项。有关更多常规自定义选项，请参阅<a href="https://exoplayer.dev/customization.html" target="_blank" rel="noopener">“ 自定义”页面</a>。</p><h3 id="（1）、设置提取器标志"><a href="#（1）、设置提取器标志" class="headerlink" title="（1）、设置提取器标志"></a>（1）、设置提取器标志</h3><p>提取器标志可用于控制如何提取单个格式。它们可以设置为 <code>DefaultExtractorsFactory</code>，然后可以在实例化时使用<code>ProgressiveMediaSource.Factory</code>。以下示例传递一个标志，该标志禁用MP4流的编辑列表解析。</p><figure class="highlight subunit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DefaultExtractorsFactory extractorsFactory =</span><br><span class="line">    new DefaultExtractorsFactory()</span><br><span class="line">        .setMp4ExtractorFlags(Mp4Extractor.FLAG_WORKAROUND_IGNORE_EDIT_LISTS);</span><br><span class="line"><span class="keyword">Progress</span>iveMediaSource progressiveMediaSource =</span><br><span class="line">    new ProgressiveMediaSource.Factory(dataSourceFactory, extractorsFactory)</span><br><span class="line">        .createMediaSource(progressiveUri);</span><br></pre></td></tr></tbody></table></figure><h3 id="（2）、启用恒定比特率搜索"><a href="#（2）、启用恒定比特率搜索" class="headerlink" title="（2）、启用恒定比特率搜索"></a>（2）、启用恒定比特率搜索</h3><p>对于MP3，ADTS和AMR流，您可以使用带<code>FLAG_ENABLE_CONSTANT_BITRATE_SEEKING</code>标志的恒定比特率假设启用近似搜索。可以使用上述方法为各个提取器设置这些标志。要为所有支持它的提取器启用恒定比特率搜索，请使用<code>DefaultExtractorsFactory.setConstantBitrateSeekingEnabled</code>。</p><figure class="highlight subunit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DefaultExtractorsFactory extractorsFactory =</span><br><span class="line">    new DefaultExtractorsFactory().setConstantBitrateSeekingEnabled(true);</span><br><span class="line"><span class="keyword">Progress</span>iveMediaSource progressiveMediaSource =</span><br><span class="line">    new ProgressiveMediaSource.Factory(dataSourceFactory, extractorsFactory)</span><br><span class="line">        .createMediaSource(progressiveUri);</span><br></pre></td></tr></tbody></table></figure><h3 id="（3）、自定义服务器交互"><a href="#（3）、自定义服务器交互" class="headerlink" title="（3）、自定义服务器交互"></a>（3）、自定义服务器交互</h3><p>某些应用可能希望拦截HTTP请求和响应。您可能希望注入自定义请求标头，读取服务器的响应标头，修改请求的URI等。例如，您的应用程序可以通过在请求媒体段时将标记作为标头注入来验证自身。您可以通过将自定义<a href="https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/upstream/HttpDataSource.html" target="_blank" rel="noopener">HttpDataSources</a>注入到<code>ProgressiveMediaSourcecreate</code>中来实现这些行为。以下代码段显示了标头注入的示例：</p><figure class="highlight subunit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Progress</span>iveMediaSource progressiveMediaSource =</span><br><span class="line">    new ProgressiveMediaSource.Factory(</span><br><span class="line">            () -&gt; {</span><br><span class="line">              HttpDataSource dataSource =</span><br><span class="line">                  new DefaultHttpDataSource(userAgent);</span><br><span class="line">              // Set a custom authentication request header.</span><br><span class="line">              dataSource.setRequestProperty("Header", "Value");</span><br><span class="line">              return dataSource;</span><br><span class="line">            })</span><br><span class="line">        .createMediaSource(progressiveUri);</span><br></pre></td></tr></tbody></table></figure><h3 id="（1）、自定义错误处理-1"><a href="#（1）、自定义错误处理-1" class="headerlink" title="（1）、自定义错误处理"></a>（1）、自定义错误处理</h3><p>实现自定义<a href="https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/upstream/LoadErrorHandlingPolicy.html" target="_blank" rel="noopener">LoadErrorHandlingPolicy</a>允许应用程序自定义ExoPlayer对加载错误的反应方式。例如，应用程序可能希望快速失败而不是多次重试，或者可能想要自定义控制玩家在每次重试之间等待多长时间的退避逻辑。以下代码段显示了在创建以下<code>ProgressiveMediaSource</code>内容时如何实现自定义退避逻辑 ：</p><figure class="highlight subunit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Progress</span>iveMediaSource progressiveMediaSource =</span><br><span class="line">    new ProgressiveMediaSource.Factory(dataSourceFactory)</span><br><span class="line">        .setLoadErrorHandlingPolicy(</span><br><span class="line">            new DefaultLoadErrorHandlingPolicy() {</span><br><span class="line">              @Override</span><br><span class="line">              public long getRetryDelayMsFor(...) {</span><br><span class="line">                // Implement custom back-off logic here.</span><br><span class="line">              }</span><br><span class="line">            })</span><br><span class="line">        .createMediaSource(progressiveUri);</span><br></pre></td></tr></tbody></table></figure><p>您可以在我们的媒体帖子中找到有关<a href="https://medium.com/google-exoplayer/load-error-handling-in-exoplayer-488ab6908137" target="_blank" rel="noopener">错误处理</a>的更多信息。</p><hr><hr><hr><blockquote><p>转载此文请标明出处：<a href="https://blog.csdn.net/MRYZJ/article/details/98657228" target="_blank" rel="noopener">https://blog.csdn.net/MRYZJ/article/details/98657228</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
          <category> ExoPlayer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> ExoPlayer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ExoPlayer详解——入门（官方文档）</title>
      <link href="/undefined/95493443.html"/>
      <url>/undefined/95493443.html</url>
      
        <content type="html"><![CDATA[<p>﻿&gt;  #####  ExoPlayer详解系列文章</p><blockquote><ul><li><a href="https://blog.csdn.net/MRYZJ/article/details/98657228" target="_blank" rel="noopener">ExoPlayer详解——入门（官方文档）</a></li><li><a href="https://blog.csdn.net/MRYZJ/article/details/98759532" target="_blank" rel="noopener">ExoPlayer详解——媒体类型（官方文档）</a></li><li><a href="https://blog.csdn.net/MRYZJ/article/details/98853258" target="_blank" rel="noopener">ExoPlayer详解——高级主题（官方文档）</a></li></ul></blockquote><h1 id="一、ExoPlayer，你好"><a href="#一、ExoPlayer，你好" class="headerlink" title="一、ExoPlayer，你好"></a>一、ExoPlayer，你好</h1><blockquote><h3 id="简单用例"><a href="#简单用例" class="headerlink" title="简单用例"></a>简单用例</h3><p>入门ExoPlayer包括实现以下步骤：</p><ul><li>将 <code>ExoPlayer</code> 添加为项目的依赖项。</li><li>创建一个 <code>SimpleExoPlayer</code> 实例。</li><li>将播放器连接到视图（用于视频输出和用户输入）。</li><li>准备 player 的 <code>MediaSource</code> 播放。</li><li>完成后释放播放器。</li></ul></blockquote><h3 id="添加ExoPlayer作为依赖项"><a href="#添加ExoPlayer作为依赖项" class="headerlink" title="添加ExoPlayer作为依赖项"></a>添加ExoPlayer作为依赖项</h3><h4 id="1、添加存储库"><a href="#1、添加存储库" class="headerlink" title="1、添加存储库"></a>1、添加存储库</h4><p>确保</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p></p><pre><code>repositories {    google()    jcenter()}</code></pre><figure class="highlight autohotkey"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### <span class="number">2</span>、添加ExoPlayer模块</span><br><span class="line"></span><br><span class="line">接下来在app目录下的```build.gradle```的文件中添加依赖项。以下内容将为完整的ExoPlayer库添加依赖项：</span><br></pre></td></tr></tbody></table></figure><pre><code>implementation 'com.google.android.exoplayer:exoplayer:2.X.X'</code></pre><figure class="highlight ruby"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`2.X.X`</span><span class="string">``</span>您的首选版本在哪里（可以通过查阅[发行说明](<span class="symbol">https:</span>/<span class="regexp">/github.com/google</span><span class="regexp">/ExoPlayer/blob</span><span class="regexp">/release-v2/</span>RELEASENOTES.md)找到最新版本）。</span><br><span class="line"></span><br><span class="line">作为完整库的替代方法，您只能依赖于实际需要的库模块。例如，以下内容将添加对Core，DASH和UI库模块的依赖关系，这对于播放DASH内容的应用程序可能是必需的：</span><br></pre></td></tr></tbody></table></figure><pre><code>implementation 'com.google.android.exoplayer:exoplayer-core:2.X.X'implementation 'com.google.android.exoplayer:exoplayer-dash:2.X.X'implementation 'com.google.android.exoplayer:exoplayer-ui:2.X.X'</code></pre><figure class="highlight autohotkey"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">下面列出了可用的库模块。向完整的ExoPlayer库添加依赖项等同于单独添加所有库模块的依赖项。</span><br><span class="line"></span><br><span class="line">+ ```exoplayer-core```：核心功能（必需）。</span><br><span class="line">+ ```exoplayer-dash```：支持DASH内容。</span><br><span class="line">+ ```exoplayer-hls```：支持HLS内容。</span><br><span class="line">+ ```exoplayer-smoothstreaming```：支持SmoothStreaming内容。</span><br><span class="line">+ ```exoplayer-ui```：用于ExoPlayer的UI组件和资源。</span><br><span class="line"></span><br><span class="line"><span class="symbol">除了库模块，ExoPlayer还有多个扩展模块，它们依赖于外部库来提供附加功能。浏览[扩展目录](https:</span>//github.com/google/ExoPlayer/tree/release-v2/extensions/)及其各自的README以获取详细信息。</span><br><span class="line"></span><br><span class="line">#### <span class="number">3</span>、打开Java <span class="number">8</span>支持</span><br><span class="line"></span><br><span class="line">如果尚未启用，则需要在所有 ```build.gradle```文件中打开Java <span class="number">8</span>支持，具体取决于ExoPlayer，方法是在以下```androi```d部分添加以下内容：</span><br></pre></td></tr></tbody></table></figure><pre><code>compileOptions {  targetCompatibility JavaVersion.VERSION_1_8}</code></pre><figure class="highlight autohotkey"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### <span class="number">4</span>、创建播放器</span><br><span class="line"></span><br><span class="line">您可以使用 ```ExoPlayer```创建实例 ```ExoPlayerFactory```。这个工厂实例提供了一系列方法来创建 ```ExoPlayer```具有不同级别自定义的实例。对于绝大多数用例， ```ExoPlayerFactory.newSimpleInstance```应该使用其中一种方法。这些方法返回 ```SimpleExoPlayer```，扩展 ```ExoPlayer```为添加额外的高级播放器功能。下面的代码是创建一个的例子  ```SimpleExoPlayer```。</span><br></pre></td></tr></tbody></table></figure><pre><code>SimpleExoPlayer player = ExoPlayerFactory.newSimpleInstance(context);</code></pre><figure class="highlight autohotkey"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">必须从单个应用程序线程访问ExoPlayer实例。对于绝大多数情况，这应该是应用程序的主线程。使用ExoPlayer的UI组件或IMA扩展时，需要使用应用程序的主线程。</span><br><span class="line"></span><br><span class="line">必须访问 ExoPlayer 实例的线程可以通过 ```Looper```在创建播放器时传递来明确指定。如果未 ```Looper```指定，则 ```Looper```使用创建播放器的线程，或者如果该线程没有 ```Looper```， ```Looper```则使用应用程序的主线程。在所有情况下， ```Looper```可以使用查询必须访问播放器的线程 ```Player.getApplicationLooper```。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### <span class="number">5</span>、将播放器附加到视图</span><br><span class="line"></span><br><span class="line">```ExoPlayer```库提供了一个 ```PlayerView```封装一个 ```PlayerControlView```，一个 ```SubtitleView```和一个 ```Surface```视频的视图。一个 ```PlayerView```可以包含在应用程序的布局 ```xml```中。将播放器绑定到视图非常简单：</span><br></pre></td></tr></tbody></table></figure><pre><code>// Bind the player to the view.playerView.setPlayer(player);</code></pre><figure class="highlight autohotkey"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果您需要精准控制播放器并在 ```Surface```上渲染视频，可以设置 ```player```的目标 ```SurfaceView```， ```TextureView```， ```SurfaceHolder```或 ```Surface```直接分别使用 ```SimpleExoPlayer```的 ```setVideoSurfaceView```， ```setVideoTextureView```， ```setVideoSurfaceHolder```和  ```setVideoSurface```的方法。您还可以将其 ```PlayerControlView```用作独立组件，或实现自己的播放控件，直接与播放器进行交互。 ```SimpleExoPlayer```的 ```setTextOutput```和 ```setId3Output```方法可用于在回放期间接收字幕和ID3元数据。</span><br><span class="line"></span><br><span class="line">#### <span class="number">6</span>、准备播放器</span><br><span class="line">在 ExoPlayer 中，每个媒体都由一个 ```MediaSource```代表。要播放媒体文件，必须首先创建一个对应的 ```MediaSource```，然后将此对象传递给 ```ExoPlayer.prepare```。 ExoPlayer 库提供  ```MediaSourceDASH（DashMediaSource）```， ```SmoothStreaming（SsMediaSource）```，```HLS（HlsMediaSource）```和常规媒体文件 ```（ProgressiveMediaSource）```的实现。以下代码显示如何准备 ```MediaSource```适合播放MP4文件的播放器。</span><br></pre></td></tr></tbody></table></figure><pre><code>// Produces DataSource instances through which media data is loaded.DataSource.Factory dataSourceFactory = new DefaultDataSourceFactory(context,Util.getUserAgent(context, "yourApplicationName"));// This is the MediaSource representing the media to be played.MediaSource videoSource = new ProgressiveMediaSource.Factory(dataSourceFactory).createMediaSource(mp4VideoUri);// Prepare the player with the source.player.prepare(videoSource);</code></pre><figure class="highlight autohotkey"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### <span class="number">7</span>、控制播放器</span><br><span class="line"></span><br><span class="line">一旦准备好了播放器，就可以通过调用播放器上的方法来控制播放。例如： ```setPlayWhenReady```开始和暂停播放，各种 ```seekTo```方法在媒体内寻找， ```setRepeatMode```控制媒体是否以及如何循环， ```setShuffleModeEnabled```控制播放列表改组，以及  ```setPlaybackParameters```调整播放速度和音高。</span><br><span class="line"></span><br><span class="line">如果 ```player```被绑定到 ```PlayerView```或 ```PlayerControlView```，则用户与这些组件的交互将导致调用播放器上的相应方法。</span><br><span class="line"></span><br><span class="line">#### <span class="number">8</span>、释放播放器</span><br><span class="line"></span><br><span class="line">在不再需要 ```player```时释放播放器非常重要，这样可以释放有限的资源，例如视频解码器，供其他应用程序使用。这可以通过调用来完成 ```ExoPlayer.release```。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"># 二、监听 Player 事件</span><br><span class="line"></span><br><span class="line">状态更改和回放错误等事件将报告给已注册的 ```Player.EventListener```实例。注册监听器以接收此类事件很容易：</span><br></pre></td></tr></tbody></table></figure><pre><code>// Add a listener to receive events from the player.player.addListener(eventListener);</code></pre><figure class="highlight autohotkey"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```Player.EventListener```具有空的默认方法，因此您只需要实现您感兴趣的方法。有关方法的完整描述以及何时调用它们，请参阅[Javadoc](https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/Player.EventListener.html)。两个最重要的是 ```onPlayerStateChanged```和 ```onPlayerError```，下面将更详细地描述。</span><br><span class="line"></span><br><span class="line">###  （一）、onPlayerStateChanged</span><br><span class="line"></span><br><span class="line">player 状态的变化可以通过 ```onPlayerStateChanged(boolean playWhenReady, int playbackState)```在注册中 实施来接收 ```Player.EventListener```。播放器可以处于以下四种播放状态之一：</span><br><span class="line"></span><br><span class="line">+ ```Player.STATE_IDLE```：这是初始状态，播放器停止时的状态以及播放失败时的状态。</span><br><span class="line">+ ```Player.STATE_BUFFERING```： player 无法立即从当前位置进行播放。这主要是因为需要加载更多数据。</span><br><span class="line">+ ```Player.STATE_READY```： player 可以立即从当前位置进行播放。</span><br><span class="line">+ ```Player.STATE_ENDED```：播放器播放完所有媒体。</span><br><span class="line"></span><br><span class="line">除了这些状态之外， player 还有一个 ```playWhenReady```标志来指示用户打算播放。如果状态为 ```Player.STATE_READY```和 ```playWhenReady=<span class="literal">true</span>```，则播放器仅播放。</span><br></pre></td></tr></tbody></table></figure><pre><code>@Overridepublic void onPlayerStateChanged(      boolean playWhenReady, @Player.State int playbackState) {  if (playWhenReady &amp;&amp; playbackState == Player.STATE_READY) {    // Active playback.  } else if (playWhenReady) {    // Not playing because playback ended, the player is buffering, stopped or    // failed. Check playbackState and player.getPlaybackError for details.  } else {    // Paused by app.  }}</code></pre><figure class="highlight autohotkey"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### （二）、 onPlayerError</span><br><span class="line"></span><br><span class="line">可以通过 ```onPlayerError(ExoPlaybackException error)```在注册中 实现来接收导致回放失败的错误 ```Player.EventListener```。发生故障时，将在播放状态转换为之前立即调用此方法 ```Player.STATE_IDLE```。 ```ExoPlaybackException```有一个 ```type```字段，以及相应的 ```getter```方法，它们返回原因异常，提供有关失败的更多信息。以下示例显示了如何检测由于HTTP网络问题导致播放失败的时间。</span><br></pre></td></tr></tbody></table></figure><pre><code>@Overridepublic void onPlayerError(ExoPlaybackException error) {  if (error.type == ExoPlaybackException.TYPE_SOURCE) {    IOException cause = error.getSourceException();    if (cause instanceof HttpDataSourceException) {      // An HTTP error occurred.      HttpDataSourceException httpError = (HttpDataSourceException) cause;      // This is the request for which the error occurred.      DataSpec requestDataSpec = httpError.dataSpec;      // It's possible to find out more about the error both by casting and by      // querying the cause.      if (httpError instanceof HttpDataSource.InvalidResponseCodeException) {        // Cast to InvalidResponseCodeException and retrieve the response code,        // message and headers.      } else {        // Try calling httpError.getCause() to retrieve the underlying cause,        // although note that it may be null.      }    }  }}</code></pre><figure class="highlight autohotkey"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### （三）、使用 EventLogger</span><br><span class="line"></span><br><span class="line">默认情况下，ExoPlayer 仅记录错误。要将播放器事件记录到控制台， ```EventLogger```可以使用该类。它提供的额外日志记录有助于了解播放器正在做什么，以及调试播放问题。 ```EventLogger```实现 ```AnalyticsListener```，因此使用 ```SimpleExoPlayer```注册实例很容易：</span><br></pre></td></tr></tbody></table></figure><pre><code>player.addAnalyticsListener(new EventLogger(trackSelector));</code></pre><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#### 1、解释日志输出</span><br><span class="line"></span><br><span class="line">观察日志的最简单方法是使用 Android Studio 的 ```logcat```选项卡。您可以通过包名称选择您的应用程序作为可调试进程（ com.google.android.exoplayer2.demo如果使用演示应用程序），并通过选择“仅显示所选应用程序”告诉logcat选项卡仅记录该应用程序。可以使用表达式进一步过滤日志记录 ```EventLogger|ExoPlayerImpl```，以便仅从日志 ```EventLogger```和播放器本身进行日志记录。</span><br><span class="line"></span><br><span class="line">使用Android Studio的logcat选项卡的另一种方法是使用控制台。例如：</span><br></pre></td></tr></tbody></table></figure><pre><code>adb logcat | grep 'EventLogger\|ExoPlayerImpl'</code></pre><figure class="highlight autohotkey"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### <span class="number">2</span>、player信息</span><br><span class="line">该 ```ExoPlayerImpl```类提供了两个关于播放器版本，运行应用程序的设备和操作系统以及已加载的 ExoPlayer 模块的重要内容：</span><br></pre></td></tr></tbody></table></figure><pre><code>ExoPlayerImpl: Release 2cd6e65 [ExoPlayerLib/2.9.6] [marlin, Pixel XL, Google, 26] [goog.exo.core, goog.exo.ui, goog.exo.dash]ExoPlayerImpl: Init 2e5194c [ExoPlayerLib/2.9.6] [marlin, Pixel XL, Google, 26]</code></pre><figure class="highlight clean"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### <span class="number">3</span>、播放状态</span><br><span class="line"></span><br><span class="line">播放器状态更改记录在以下行中。在此示例中，播放永远不会重建（在初始缓冲之后）并且用户暂停一次：</span><br></pre></td></tr></tbody></table></figure><pre><code>EventLogger: state [0.00, 0.00, window=0, true, BUFFERING]EventLogger: state [0.92, 0.04, window=0, period=0, true, READY]EventLogger: state [11.53, 10.60, window=0, period=0, false, READY]EventLogger: state [14.26, 10.60, window=0, period=0, true, READY]EventLogger: state [131.89, 128.27, window=0, period=0, true, ENDED]</code></pre><figure class="highlight autohotkey"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">方括号内的元素是：</span><br><span class="line"></span><br><span class="line">+ ```[float]```：自 player 创建以来的挂钟时间。</span><br><span class="line">+ ```[float]```：当前播放位置。</span><br><span class="line">+ ```[window=int]```：当前窗口索引。</span><br><span class="line">+ ```[period=int]```：该窗口中的当前时段。</span><br><span class="line">+ ```[boolean]```： ```playWhenReady```标志。</span><br><span class="line">+ ```[string]```：当前播放状态。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### <span class="number">4</span>、媒体曲目</span><br><span class="line"></span><br><span class="line">当可用或选定的曲目发生变化时，将记录曲目信息。这在回放开始时至少发生一次。以下示例显示了自适应流的跟踪日志记录：</span><br></pre></td></tr></tbody></table></figure><pre><code>EventLogger: tracksChanged [2.32, 0.00, window=0, period=0,EventLogger:   Renderer:0 [EventLogger:     Group:0, adaptive_supported=YES [EventLogger:       [X] Track:0, id=133, mimeType=video/avc, bitrate=261112, codecs=avc1.4d4015, res=426x240, fps=30.0, supported=YESEventLogger:       [X] Track:1, id=134, mimeType=video/avc, bitrate=671331, codecs=avc1.4d401e, res=640x360, fps=30.0, supported=YESEventLogger:       [X] Track:2, id=135, mimeType=video/avc, bitrate=1204535, codecs=avc1.4d401f, res=854x480, fps=30.0, supported=YESEventLogger:       [X] Track:3, id=160, mimeType=video/avc, bitrate=112329, codecs=avc1.4d400c, res=256x144, fps=30.0, supported=YESEventLogger:       [X] Track:4, id=136, mimeType=video/avc, bitrate=2400538, codecs=avc1.4d401f, res=1280x720, fps=30.0, supported=YESEventLogger:     ]EventLogger:   ]EventLogger:   Renderer:1 [EventLogger:     Group:0, adaptive_supported=YES_NOT_SEAMLESS [EventLogger:       [ ] Track:0, id=139, mimeType=audio/mp4a-latm, bitrate=48582, codecs=mp4a.40.5, channels=2, sample_rate=22050, supported=YESEventLogger:       [X] Track:1, id=140, mimeType=audio/mp4a-latm, bitrate=127868, codecs=mp4a.40.2, channels=2, sample_rate=44100, supported=YESEventLogger:     ]EventLogger:   ]EventLogger: ]</code></pre><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">播放自适应流时，播放期间会记录正在播放的格式的更改以及所选曲目的属性：</span><br></pre></td></tr></tbody></table></figure><pre><code>EventLogger: downstreamFormatChanged [3.64, 0.00, window=0, period=0, id=134, mimeType=video/avc, bitrate=671331, codecs=avc1.4d401e, res=640x360, fps=30.0]EventLogger: downstreamFormatChanged [3.64, 0.00, window=0, period=0, id=140, mimeType=audio/mp4a-latm, bitrate=127868, codecs=mp4a.40.2, channels=2, sample_rate=44100]</code></pre><figure class="highlight autohotkey"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### <span class="number">3</span>、解码器选择</span><br><span class="line"></span><br><span class="line">在大多数情况下，ExoPlayer使用 ```MediaCodec```从底层平台获取的媒体来呈现媒体。在报告任何播放状态之前，您将找到记录，告诉您哪些解码器已初始化。例如：</span><br></pre></td></tr></tbody></table></figure><pre><code>EventLogger: decoderInitialized [0.77, 0.00, window=0, period=0, video, OMX.qcom.video.decoder.avc]EventLogger: decoderInitialized [0.79, 0.00, window=0, period=0, audio, OMX.google.aac.decoder]</code></pre><figure class="highlight ruby"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">---</span><br><span class="line"><span class="comment"># 三、媒体来源</span></span><br><span class="line">在ExoPlayer中，每个媒体都由 <span class="string">``</span><span class="string">`MediaSource`</span><span class="string">``</span>代表。ExoPlayer库提供 <span class="string">`MediaSource`</span> 了多种流类型的实现：</span><br><span class="line"></span><br><span class="line">- <span class="string">`DashMediaSource`</span>对于[**DASH**](<span class="symbol">https:</span>/<span class="regexp">/exoplayer.dev/dash</span>.html)。</span><br><span class="line">- <span class="string">`SsMediaSource`</span>对于[**SmoothStreaming**](<span class="symbol">https:</span>/<span class="regexp">/exoplayer.dev/smoothstreaming</span>.html)。</span><br><span class="line">- <span class="string">`HlsMediaSource`</span>对于[**HLS**](<span class="symbol">https:</span>/<span class="regexp">/exoplayer.dev/hls</span>.html)。</span><br><span class="line">- <span class="string">`ProgressiveMediaSource`</span>对于[**常规媒体文件**](<span class="symbol">https:</span>/<span class="regexp">/exoplayer.dev/progressive</span>.html)。</span><br><span class="line"></span><br><span class="line">可以 <span class="string">``</span><span class="string">`PlayerActivity`</span><span class="string">``</span>在[主演示应用程序中](<span class="symbol">https:</span>/<span class="regexp">/github.com/google</span><span class="regexp">/ExoPlayer/tree</span><span class="regexp">/release-v2/demos</span><span class="regexp">/main/</span>)找到实例化所有四个的[示例](<span class="symbol">https:</span>/<span class="regexp">/github.com/google</span><span class="regexp">/ExoPlayer/tree</span><span class="regexp">/release-v2/demos</span><span class="regexp">/main/</span>)。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 1、MediaSource组成</span></span><br><span class="line">除了上面描述的 <span class="string">`MediaSource`</span> 的实现方式中，ExoPlayer库还提供 <span class="string">`ConcatenatingMediaSource`</span> ， <span class="string">`ClippingMediaSource`</span> ， <span class="string">`LoopingMediaSource`</span> 和 <span class="string">`MergingMediaSource`</span> 。这些 <span class="string">`MediaSource`</span> 实现通过组合实现更复杂的回放功能。一些常见用例如下所述。请注意，尽管在视频播放的 <span class="string">`context`</span> 中描述了以下一些示例，但它们同样适用于仅音频播放，并且实际上适用于任何支持的媒体类型的播放。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 2、播放播放列表</span></span><br><span class="line">使用支持播放列表 <span class="string">`ConcatenatingMediaSource`</span> ，可以连续播放多个 <span class="string">`MediaSource`</span> 。可以通过在播放期间添加，移除和移动 <span class="string">`MediaSource`</span> 来动态修改播放列表 <span class="string">`ConcatenatingMediaSource`</span> 。有关详细信息，请参阅[播放列表页面](<span class="symbol">https:</span>/<span class="regexp">/exoplayer.dev/playlists</span>.html)。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 3、剪辑视频</span></span><br><span class="line"><span class="string">`ClippingMediaSource`</span> 可用于剪辑 <span class="string">`MediaSource`</span> 以便只播放部分内容。以下示例将视频播放剪辑为以<span class="number">5</span>秒开始并以<span class="number">10</span>秒结束。</span><br></pre></td></tr></tbody></table></figure><pre><code>MediaSource videoSource =    new ProgressiveMediaSource.Factory(...).createMediaSource(videoUri);// Clip to start at 5 seconds and end at 10 seconds.ClippingMediaSource clippingSource =    new ClippingMediaSource(        videoSource,        /* startPositionUs= */ 5_000_000,        /* endPositionUs= */ 10_000_000);</code></pre><figure class="highlight autohotkey"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">要仅剪辑源的开头， `endPositionUs` 可以设置为 `C.TIME_END_OF_SOURCE` 。要仅剪切到特定的持续时间，有一个构造函数接受一个 `durationUs` 参数。</span><br><span class="line"></span><br><span class="line">&gt; 剪切视频文件的开头时，尽可能将起始位置与关键帧对齐。如果开始位置未与关键帧对齐，则播放器将需要解码并丢弃从先前关键帧到开始位置的数据，然后才能开始播放。这将在播放开始时引入短暂的延迟，包括当播放器转换为播放 ClippingMediaSource播放列表的一部分或由于循环播放时。</span><br><span class="line"></span><br><span class="line">### <span class="number">4</span>、循环播放视频</span><br><span class="line">&gt; 要无限循环播放，比起 `LoopingMediaSource` 最好使用 `ExoPlayer.setRepeatMode` 。</span><br><span class="line"></span><br><span class="line">视频可以使用 `LoopingMediaSource` 无缝循环固定次数。以下示例播放视频两次。</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">MediaSource source =</span><br><span class="line">    <span class="keyword">new</span> ProgressiveMediaSource.Factory(...).createMediaSource(videoUri)<span class="comment">;</span></span><br><span class="line">// Plays the video twice.</span><br><span class="line">LoopingMediaSource loopingSource = <span class="keyword">new</span> LoopingMediaSource(source, <span class="number">2</span>)<span class="comment">;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="5、侧加载字幕文件"><a href="#5、侧加载字幕文件" class="headerlink" title="5、侧加载字幕文件"></a>5、侧加载字幕文件</h3><p>给定视频文件和单独的字幕文件， <code>MergingMediaSource</code> 可用于将它们合并为单个源以进行回放。</p><figure class="highlight haxe"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Build the video MediaSource.</span></span><br><span class="line">MediaSource videoSource =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">ProgressiveMediaSource</span>.Factory(...).createMediaSource(videoUri);</span><br><span class="line"><span class="comment">// Build the subtitle MediaSource.</span></span><br><span class="line">Format subtitleFormat = Format.createTextSampleFormat(</span><br><span class="line">    id, <span class="comment">// An identifier for the track. May be null.</span></span><br><span class="line">    MimeTypes.APPLICATION_SUBRIP, <span class="comment">// The mime type. Must be set correctly.</span></span><br><span class="line">    selectionFlags, <span class="comment">// Selection flags for the track.</span></span><br><span class="line">    language); <span class="comment">// The subtitle language. May be null.</span></span><br><span class="line">MediaSource subtitleSource =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">SingleSampleMediaSource</span>.Factory(...)</span><br><span class="line">        .createMediaSource(subtitleUri, subtitleFormat, C.TIME_UNSET);</span><br><span class="line"><span class="comment">// Plays the video with the sideloaded subtitle.</span></span><br><span class="line">MergingMediaSource mergedSource =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">MergingMediaSource</span>(videoSource, subtitleSource);</span><br></pre></td></tr></tbody></table></figure><h3 id="6、先进的结构"><a href="#6、先进的结构" class="headerlink" title="6、先进的结构"></a>6、先进的结构</h3><p>可以进一步组合成复杂的 <code>MediaSource</code> 以用于更多不寻常的实例。给定两个视频A和B，以下示例显示如何可以一起使用 <code>LoopingMediaSource</code> 和 <code>ConcatenatingMediaSource</code> 来播放序列（A，A，B）。</p><figure class="highlight haxe"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MediaSource firstSource =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">ProgressiveMediaSource</span>.Factory(...).createMediaSource(firstVideoUri);</span><br><span class="line">MediaSource secondSource =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">ProgressiveMediaSource</span>.Factory(...).createMediaSource(secondVideoUri);</span><br><span class="line"><span class="comment">// Plays the first video twice.</span></span><br><span class="line">LoopingMediaSource firstSourceTwice = <span class="keyword">new</span> <span class="type">LoopingMediaSource</span>(firstSource, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// Plays the first video twice, then the second video.</span></span><br><span class="line">ConcatenatingMediaSource concatenatedSource =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">ConcatenatingMediaSource</span>(firstSourceTwice, secondSource);</span><br></pre></td></tr></tbody></table></figure><p>以下示例是等效的，表明可以有多种方法来实现相同的结果。</p><figure class="highlight haxe"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MediaSource firstSource =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">ProgressiveMediaSource</span>.Factory(...).createMediaSource(firstVideoUri);</span><br><span class="line">MediaSource secondSource =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">ProgressiveMediaSource</span>.Factory(...).createMediaSource(secondVideoUri);</span><br><span class="line"><span class="comment">// Plays the first video twice, then the second video.</span></span><br><span class="line">ConcatenatingMediaSource concatenatedSource =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">ConcatenatingMediaSource</span>(firstSource, firstSource, secondSource);</span><br></pre></td></tr></tbody></table></figure><hr><hr><h1 id="四、播放列表"><a href="#四、播放列表" class="headerlink" title="四、播放列表"></a>四、播放列表</h1><p>使用支持播放列表的 <code>ConcatenatingMediaSource</code> ，可以连续播放多个 <code>MediaSource</code> 。以下示例表示由两个视频组成的播放列表。</p><figure class="highlight haxe"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MediaSource firstSource =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">ProgressiveMediaSource</span>.Factory(...).createMediaSource(firstVideoUri);</span><br><span class="line">MediaSource secondSource =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">ProgressiveMediaSource</span>.Factory(...).createMediaSource(secondVideoUri);</span><br><span class="line"><span class="comment">// Plays the first video, then the second video.</span></span><br><span class="line">ConcatenatingMediaSource concatenatedSource =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">ConcatenatingMediaSource</span>(firstSource, secondSource);</span><br></pre></td></tr></tbody></table></figure><p>播放列表中的项目之间的转换是 <strong>无缝</strong> 的。并不要求它们具有相同的格式（例如，播放列表包含H264和VP9视频都很好）。它们甚至可以是不同类型的（例如，播放列表包含视频和仅音频流都很好）。允许 <code>MediaSource</code> 在播放列表中多次使用相同的内容。</p><h3 id="1、修改播放列表"><a href="#1、修改播放列表" class="headerlink" title="1、修改播放列表"></a>1、修改播放列表</h3><p>可以通过在 <code>ConcatenatingMediaSource</code> 中添加，删除和移动 <code>MediaSource</code> 来动态修改播放列表。这可以通过调用相应的 <code>ConcatenatingMediaSource</code> 方法在回放之前和回放期间完成。播放器以正确的方式自动处理播放期间的修改。例如，如果当前正在播放 <code>MediaSource</code> ，则不会中断播放，并且将在完成时播放其新的后继播放。如果当前播放 <code>MediaSource</code> 被移除，则播放器将自动移动到播放第一个剩余的后继者，或者如果不存在这样的后继者则转换到结束状态。</p><h3 id="2、识别播放列表项"><a href="#2、识别播放列表项" class="headerlink" title="2、识别播放列表项"></a>2、识别播放列表项</h3><p>为了简化播放列表项的识别， <code>MediaSource</code> 可以在工厂类中使用自定义标签设置每个项目 <code>MediaSource</code> ，这可以是uri，标题或任何其他自定义对象。可以使用查询当前正在播放的项目的标签 <code>player.getCurrentTag</code> 。 <code>player.getCurrentTimeline</code> 返回的当前值<code>Timeline</code> 还包含所有标记作为 <code>Timeline.Window</code> 对象的一部分 。</p><figure class="highlight aspectj"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">addItem</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="comment">// Add mediaId (e.g. uri) as tag to the MediaSource.</span></span><br><span class="line">  MediaSource mediaSource =</span><br><span class="line">      <span class="keyword">new</span> ProgressiveMediaSource.Factory(...)</span><br><span class="line">          .setTag(mediaId)</span><br><span class="line">          .createMediaSource(uri);</span><br><span class="line">  concatenatedSource.addMediaSource(mediaSource);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onPositionDiscontinuity</span><span class="params">(@Player.DiscontinuityReason <span class="keyword">int</span> reason)</span> </span>{</span><br><span class="line">  <span class="comment">// Load metadata for mediaId and update the UI.</span></span><br><span class="line">  CustomMetadata metadata = CustomMetadata.get(player.getCurrentTag());</span><br><span class="line">  titleView.setText(metadata.getTitle());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="3、检测播放何时转换到另一个项目"><a href="#3、检测播放何时转换到另一个项目" class="headerlink" title="3、检测播放何时转换到另一个项目"></a>3、检测播放何时转换到另一个项目</h3><p>当前播放项目更改时，可以调用三种类型的事件：</p><ul><li><code>EventListener.onPositionDiscontinuity</code> 与 <code>reason = Player.DISCONTINUITY_REASON_PERIOD_TRANSITION</code>。当播放自动从一个项目转换到下一个项目时会发生这种情况</li><li><code>EventListener.onPositionDiscontinuity</code> 与 <code>reason = Player.DISCONTINUITY_REASON_SEEK</code>。当当前播放项目作为搜索操作的一部分而改变时，例如在呼叫时，会发生这种情况 <code>Player.next</code>。</li><li><code>EventListener.onTimelineChanged</code> 与 <code>reason = Player.TIMELINE_CHANGE_REASON_DYNAMIC</code> 。当播放列表发生更改时会发生这种情况，例如，如果添加，移动或删除项目。</li></ul><p>在所有情况下，当您的应用程序代码收到事件时，您可以查询播放器以确定播放列表中正在播放的项目。这可以使用诸如 <code>Player.getCurrentWindowIndex</code> 和 <code>Player.getCurrentTag</code> 之类的方法来完成。如果您只想检测播放列表项目更改，则必须与最后一个已知的窗口索引或标记进行比较，因为上述事件可能由于其他原因而被触发。</p><hr><hr><h1 id="五、TrackSelector"><a href="#五、TrackSelector" class="headerlink" title="五、TrackSelector"></a>五、TrackSelector</h1><p>曲目选择确定播放器播放哪些可用媒体曲目。轨道选择是<code>TrackSelector</code>的责任，可以在<code>ExoPlayer</code>构建时提供其实例。</p><figure class="highlight ebnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">DefaultTrackSelector trackSelector</span> = new DefaultTrackSelector();</span><br><span class="line"><span class="attribute">SimpleExoPlayer player</span> =</span><br><span class="line">    ExoPlayerFactory.newSimpleInstance(context, trackSelector);</span><br></pre></td></tr></tbody></table></figure><p><code>DefaultTrackSelector</code> <code>TrackSelector</code>适用于大多数用例的灵活性。使用<code>DefaultTrackSelector</code> 时，可以通过修改它来控制它选择的轨道 <code>Parameters</code> 。这可以在播放之前或播放期间完成。例如，以下代码告诉选择器将视频轨道选择限制为SD，并选择德语音轨（如果有）：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">trackSelector</span><span class="selector-class">.setParameters</span>(</span><br><span class="line">    <span class="selector-tag">trackSelector</span></span><br><span class="line">        <span class="selector-class">.buildUponParameters</span>()</span><br><span class="line">        <span class="selector-class">.setMaxVideoSizeSd</span>()</span><br><span class="line">        <span class="selector-class">.setPreferredAudioLanguage</span>("<span class="selector-tag">deu</span>"));</span><br></pre></td></tr></tbody></table></figure><p>这是基于约束的轨道选择的示例，其中在不知道实际可用的轨道的情况下指定约束。可以使用指定许多不同类型的约束 <code>Parameters</code> 。 <code>Parameters</code> 也可用于从可用的轨道中选择特定轨道。有关更多详细信息<a href="https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.html" target="_blank" rel="noopener">DefaultTrackSelector</a>，请参阅<a href="https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.Parameters.html" target="_blank" rel="noopener">Parameters</a>和<a href="https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/trackselection/DefaultTrackSelector.ParametersBuilder.html" target="_blank" rel="noopener">ParametersBuilder</a>文档。</p><hr><hr><h1 id="六、UI组件"><a href="#六、UI组件" class="headerlink" title="六、UI组件"></a>六、UI组件</h1><p>应用程序播放媒体需要用户界面组件来显示媒体和控制播放。ExoPlayer库包含一个包含许多UI组件的UI模块。要依赖UI模块添加依赖项，如下所示，2.X.X您的首选版本在哪里（可以通过查阅发行说明找到最新版本）。</p><pre><code>implementation 'com.google.android.exoplayer:exoplayer-ui:2.X.X'</code></pre><p>最重要的组件是 <code>PlayerControlView</code> 和 <code>PlayerView</code> 。</p><ul><li><code>PlayerControlView</code>是用于控制播放的视图。它显示标准播放控件，包括播放/暂停按钮，快进和快退按钮以及搜索栏。</li><li><code>PlayerView</code>是播放的高级视图。它在播放期间显示视频，字幕和专辑封面，以及使用<code>PlayerControlView</code>播放控件 。</li></ul><p>两个视图都有一个 <code>setPlayer</code> 附加和分离（通过传递 null）播放器实例的方法。</p><h3 id="1、PlayerView"><a href="#1、PlayerView" class="headerlink" title="1、PlayerView"></a>1、PlayerView</h3><p><code>PlayerView</code> 可用于视频和音频播放。它在视频播放的情况下呈现视频和字幕，并且可以在音频文件中显示作为元数据包括的艺术作品。您可以在布局文件中像其他UI组件中一样，加载<code>PlayerView</code> ：</p><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;com.google.android.exoplayer2.ui.PlayerView</span><br><span class="line">    android:<span class="attribute">id</span>=<span class="string">"@+id/player_view"</span></span><br><span class="line">    android:<span class="attribute">layout_width</span>=<span class="string">"match_parent"</span></span><br><span class="line">    android:<span class="attribute">layout_height</span>=<span class="string">"match_parent"</span></span><br><span class="line">    app:<span class="attribute">show_buffering</span>=<span class="string">"when_playing"</span></span><br><span class="line">    app:<span class="attribute">show_shuffle_button</span>=<span class="string">"true"</span>/&gt;</span><br></pre></td></tr></tbody></table></figure><p>上面的代码片段说明了<code>PlayerView</code>提供了几个属性。这些属性可用于自定义视图的行为及其外观。这些属性中的大多数都具有相应的<code>setter</code>方法，可用于在运行时自定义视图。该 <a href="https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/ui/PlayerView.html" target="_blank" rel="noopener">PlayerView</a>的Javadoc文档中详细介绍这些属性和setter方法。</p><p>一旦<code>PlayerView</code>在布局文件中声明，就可以<code>onCreate</code>在活动的方法中查找它：</p><figure class="highlight aspectj"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{</span><br><span class="line">  <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  playerView = findViewById(R.id.player_view);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当player初始化时，可以通过调用setPlayer以下内容将其附加到视图 ：</p><figure class="highlight sqf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Instantiate the player.</span></span><br><span class="line"><span class="built_in">player</span> = ExoPlayerFactory.newSimpleInstance(context);</span><br><span class="line"><span class="comment">// Attach player to the view.</span></span><br><span class="line">playerView.setPlayer(<span class="built_in">player</span>);</span><br><span class="line"><span class="comment">// Prepare the player with the dash media source.</span></span><br><span class="line"><span class="built_in">player</span>.prepare(createMediaSource());</span><br></pre></td></tr></tbody></table></figure><h3 id="2、选择Surface类型"><a href="#2、选择Surface类型" class="headerlink" title="2、选择Surface类型"></a>2、选择Surface类型</h3><p>该<code>surface_type</code>属性<code>PlayerView</code>可让您设置用于视频播放的<code>Surface</code>类型。除了值<code>spherical_view</code>（这是球形视频播放一个特殊的值）时，允许值是<code>surface_view</code>， <code>texture_view</code>和<code>none</code>。如果视图仅用于音频播放，则应使用<code>none</code>以避免必须创建<code>Surface</code>，因为这样做可能耗费资源。</p><p>如果视图是用于常规视频播放那么 <code>surface_view</code> 或 <code>texture_view</code> 应该使用。对于视频播放，相比<code>TextureView</code>，<code>SurfaceView</code>有许多好处：</p><ul><li>显着降低了许多设备的功耗。</li><li>更准确的帧定时，使视频播放更流畅。</li><li>播放受DRM保护的内容时支持安全输出。</li></ul><p>因此，相比较于<code>TextureView</code>，<code>SurfaceView</code>应尽可能优先考虑。 <code>TextureView</code>只有在<code>SurfaceView</code>不符合您需求的情况下才能使用。一个示例是在Android N之前需要平滑动画或滚动视频表面，如下所述。对于这种情况，最好 <code>TextureView</code> 只在<a href="https://developer.android.com/reference/android/os/Build.VERSION.html#SDK_INT" target="_blank" rel="noopener">SDK_INT</a>小于24（Android N）时使用， 否则，使用SurfaceView。</p><blockquote><p><code>SurfaceView</code>在Android N之前，渲染未与视图动画正确同步。在早期版本<code>SurfaceView</code>中，当放入滚动容器或受到动画影响时，这可能会导致不必要的效果 。这些效果包括视图的内容看起来略微落后于它应该显示的位置，并且视图在受到动画时变黑。为了在Android N之前实现流畅的动画或视频滚动，因此必须使用<code>TextureView</code>而不是<code>SurfaceView</code>。</p></blockquote><h3 id="3、PlayerControlView"><a href="#3、PlayerControlView" class="headerlink" title="3、PlayerControlView"></a>3、PlayerControlView</h3><p>当使用 <code>PlayerView</code> 时， <code>PlayerControlView</code> 在内部用于提供播放控制。对于特定用例 <code>PlayerControlView</code> ，也可以用作独立组件。它可以像任何其他UI组件一样包含在布局文件中：</p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;com<span class="selector-class">.google</span><span class="selector-class">.android</span><span class="selector-class">.exoplayer2</span><span class="selector-class">.ui</span><span class="selector-class">.PlayerControlView</span></span><br><span class="line">    android:id=<span class="string">"@+id/player_control_view"</span></span><br><span class="line">    android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"match_parent"</span>/&gt;</span><br></pre></td></tr></tbody></table></figure><p>比起 <code>PlayerView</code> ， <a href="https://exoplayer.dev/doc/reference/com/google/android/exoplayer2/ui/PlayerControlView.html" target="_blank" rel="noopener">PlayerControlView</a> 的Javadoc更详细地记录了可用的属性和<code>setter</code>方法。查找 <code>PlayerControlView</code> 并将播放器附加到视图与使用时类似<code>PlayerView</code>：</p><figure class="highlight aspectj"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>{</span><br><span class="line">  <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  playerControlView = findViewById(R.id.player_control_view);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">initializePlayer</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="comment">// Instantiate the player.</span></span><br><span class="line">  player = ExoPlayerFactory.newSimpleInstance(context);</span><br><span class="line">  <span class="comment">// Attach player to the view.</span></span><br><span class="line">  playerControlView.setPlayer(player);</span><br><span class="line">  <span class="comment">// Prepare the player with the dash media source.</span></span><br><span class="line">  player.prepare(createMediaSource());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="4、覆盖布局文件"><a href="#4、覆盖布局文件" class="headerlink" title="4、覆盖布局文件"></a>4、覆盖布局文件</h3><p>当<code>PlayerView</code>被实例化后，它从布局文件 <code>exo_player_view.xml</code>扩展 （<code>inflate</code>） 它的布局。<code>PlayerControlView</code>从 <code>exo_player_control_view.xml</code>中扩展其布局。要自定义这些布局，应用程序可以在其自己的<code>res/layout*</code>目录中定义具有相同名称的布局文件。这些布局文件会覆盖ExoPlayer库提供的文件。</p><p>例如，假设我们希望我们的播放控件仅包含位于视图中心的播放/暂停按钮。我们可以通过exo_player_control_view.xml在应用程序的res/layout 目录中创建文件来实现这一点，包含：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">ImageButton</span> <span class="attr">android:id</span>=<span class="string">"@id/exo_play"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_width</span>=<span class="string">"100dp"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_height</span>=<span class="string">"100dp"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_gravity</span>=<span class="string">"center"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:background</span>=<span class="string">"#CC000000"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">style</span>=<span class="string">"@style/ExoMediaButton.Play"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">ImageButton</span> <span class="attr">android:id</span>=<span class="string">"@id/exo_pause"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_width</span>=<span class="string">"100dp"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_height</span>=<span class="string">"100dp"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:layout_gravity</span>=<span class="string">"center"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:background</span>=<span class="string">"#CC000000"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">style</span>=<span class="string">"@style/ExoMediaButton.Pause"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>与标准对照相比，视觉外观的变化如下所示。<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://img-blog.csdnimg.cn/20190806202341249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01SWVpK,size_16,color_FFFFFF,t_70" alt="使用自定义控件替换标准播放控件"></p><h3 id="5、自定义布局文件"><a href="#5、自定义布局文件" class="headerlink" title="5、自定义布局文件"></a>5、自定义布局文件</h3><p>覆盖布局文件是改变整个应用程序布局的绝佳解决方案，但是如果仅在一个地方需要自定义布局呢？要实现这一点，首先要定义一个布局文件，就像覆盖其中一个默认布局一样，但这次给它一个不同的文件名<code>custom_controls.xml</code>。其次，使用属性指示在对视图进行扩展（<code>inflate</code>）时应使用此布局。例如，在使用时 <code>PlayerView</code>，可以使用以下<code>controller_layout_id</code>属性指定扩展（<code>inflate</code>）以提供播放控件的布局：</p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;com<span class="selector-class">.google</span><span class="selector-class">.android</span><span class="selector-class">.exoplayer2</span><span class="selector-class">.ui</span><span class="selector-class">.PlayerView</span> </span><br><span class="line"> android:id=<span class="string">"@+id/player_view"</span></span><br><span class="line">     android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">     android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">     app:controller_layout_id=<span class="string">"@layout/custom_controls"</span>/&gt;</span><br></pre></td></tr></tbody></table></figure><hr><hr><h1 id="七、下载媒体"><a href="#七、下载媒体" class="headerlink" title="七、下载媒体"></a>七、下载媒体</h1><p>ExoPlayer提供下载媒体以进行离线播放的功能。在大多数用例中，即使您的应用程序处于后台，也可以继续下载。对于这些用例，您的应用程序应该是子类DownloadService，并将命令发送到服务以添加，删除和控制下载。下图显示了涉及的主要类。<br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://img-blog.csdnimg.cn/20190806202643758.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01SWVpK,size_16,color_FFFFFF,t_70" alt="下载媒体的类。箭头方向表示数据流。"></p><ul><li><code>DownloadService</code>：包装<code>DownloadManager</code>并转发命令。该服务允许<code>DownloadManager</code>即使应用程序在后台运行也能继续运行。</li><li><code>DownloadManager</code>：管理多个下载，根据网络连接等要求加载（和存储）来自（和） <code>DownloadIndex</code>的状态，启动和停止下载。要下载内容，管理员通常会读取从<code>HttpDataSource</code>下载的数据 ，并将其写入<code>Cache</code>。</li><li><code>DownloadIndex</code>：保持下载状态。</li></ul><h3 id="1、创建DownloadService"><a href="#1、创建DownloadService" class="headerlink" title="1、创建DownloadService"></a>1、创建DownloadService</h3><p>要创建一个<code>DownloadService</code>，您需要将其子类化并实现其抽象方法：</p><ul><li><code>getDownloadManager()</code>：返回<code>DownloadManager</code>要使用的。</li><li><code>getScheduler()</code>：返回一个可选项<code>Scheduler</code>，可以在满足挂起下载进度所需的需求时重新启动服务。<code>ExoPlayer</code>提供两种实现：<ul><li><code>PlatformScheduler</code>，它使用<a href="https://developer.android.com/reference/android/app/job/JobScheduler" target="_blank" rel="noopener">JobScheduler</a>。</li><li><code>JobDispatcherScheduler</code>，它使用 <a href="https://github.com/firebase/firebase-jobdispatcher-android" target="_blank" rel="noopener">Firebase JobDispatcher</a>。</li></ul></li><li><code>getForegroundNotification()</code>：返回服务在前台运行时要显示的通知。您可以使用 <code>DownloadNotificationHelper.buildProgressNotification</code>默认样式创建通知。</li></ul><p>最后，您需要在<code>AndroidManifest.xml</code>文件中定义服务：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">"com.myapp.MyDownloadService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- This is needed for Scheduler --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.google.android.exoplayer.downloadService.action.RESTART"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>见<code>DemoDownloadService</code>和<code>AndroidManifest.xml</code>在一个具体的例子中ExoPlayer演示应用程序。</p><h3 id="2、创建-DownloadManager"><a href="#2、创建-DownloadManager" class="headerlink" title="2、创建 DownloadManager"></a>2、创建 DownloadManager</h3><p>下面的代码片段演示了如何实例化一个<code>DownloadManager</code>，可以通过返回<code>getDownloadManager()</code>在<code>DownloadService</code>：</p><figure class="highlight haxe"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note: This should be a singleton in your app.</span></span><br><span class="line">databaseProvider = <span class="keyword">new</span> <span class="type">ExoDatabaseProvider</span>(context);</span><br><span class="line"></span><br><span class="line"><span class="comment">// A download cache should not evict media, so should use a NoopCacheEvictor.</span></span><br><span class="line">downloadCache = <span class="keyword">new</span> <span class="type">SimpleCache</span>(</span><br><span class="line">    downloadDirectory,</span><br><span class="line">    <span class="keyword">new</span> <span class="type">NoOpCacheEvictor</span>(),</span><br><span class="line">    databaseProvider);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a factory for reading the data from the network.</span></span><br><span class="line">dataSourceFactory = <span class="keyword">new</span> <span class="type">DefaultHttpDataSourceFactory</span>(userAgent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the download manager.</span></span><br><span class="line">downloadManager = <span class="keyword">new</span> <span class="type">DownloadManager</span>(</span><br><span class="line">    context,</span><br><span class="line">    databaseProvider,</span><br><span class="line">    downloadCache,</span><br><span class="line">    dataSourceFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Optionally, setters can be called to configure the download manager.</span></span><br><span class="line">downloadManager.setRequirements(requirements);</span><br><span class="line">downloadManager.setMaxParallelDownloads(<span class="number">3</span>);</span><br></pre></td></tr></tbody></table></figure><p>请参阅<code>DemoApplication</code>演示应用程序中的具体示例。</p><blockquote><p>演示应用程序中的示例还从旧 <code>ActionFile</code> 实例导入下载状态。只有<code>ActionFile</code>在<code>ExoPlayer 2.10.0</code>之前使用您的应用程序时才需要这样做。</p></blockquote><h3 id="3、添加下载"><a href="#3、添加下载" class="headerlink" title="3、添加下载"></a>3、添加下载</h3><p>要添加下载，您需要创建一个<code>DownloadRequest</code>并将其发送给您 <code>DownloadService</code>。对于自适应流，<code>DownloadHelper</code>可以用来帮助构建一个<code>DownloadRequest</code>，如本页后面所述。以下示例显示了如何为渐进式流创建下载请求：</p><figure class="highlight autohotkey"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DownloadRequest downloadRequest = <span class="keyword">new</span> DownloadRequest(</span><br><span class="line"><span class="built_in">    contentId,</span></span><br><span class="line">    DownloadRequest.TYPE_PROGRESSIVE,</span><br><span class="line"><span class="built_in">    contentUri,</span></span><br><span class="line">    <span class="comment">/* streamKeys= */</span> Collections.emptyList(),</span><br><span class="line">    <span class="comment">/* customCacheKey= */</span> null,</span><br><span class="line">    appData)<span class="comment">;</span></span><br></pre></td></tr></tbody></table></figure><p><code>contentId</code>是内容的唯一标识符，<code>appData</code>是应用程序希望与下载关联的任何数据。在简单的情况下， <code>contentUri</code>通常可以使用<code>contentId</code>，但应用程序可以自由使用任何最适合其用例的ID方案。</p><p>创建后，可以将请求发送<code>DownloadService</code>到添加下载：</p><figure class="highlight autohotkey"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DownloadService.sendAddDownload(</span><br><span class="line"><span class="built_in">    context,</span></span><br><span class="line">    MyDownloadService.class,</span><br><span class="line"><span class="built_in">    downloadRequest,</span></span><br><span class="line">    <span class="comment">/* foreground= */</span> <span class="literal">false</span>)</span><br></pre></td></tr></tbody></table></figure><p><code>MyDownloadServiceapp</code>的<code>DownloadService</code>子类在哪里， <code>foreground</code>参数控制是否在前台启动服务。如果你的应用程序已经在前台，那么<code>foreground</code>通常应该将参数设置为<code>false</code>，因为<code>DownloadService</code>如果它确定它有工作要做，它将把自己置于前台。</p><h3 id="4、删除下载"><a href="#4、删除下载" class="headerlink" title="4、删除下载"></a>4、删除下载</h3><p>可以通过发送删除命令来删除下载<code>DownloadService</code>，其中<code>contentId</code>标识要删除的下载：</p><figure class="highlight autohotkey"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DownloadService.sendRemoveDownload(</span><br><span class="line"><span class="built_in">    context,</span></span><br><span class="line">    MyDownloadService.class,</span><br><span class="line"><span class="built_in">    contentId,</span></span><br><span class="line">    <span class="comment">/* foreground= */</span> <span class="literal">false</span>)</span><br></pre></td></tr></tbody></table></figure><p>您还可以删除所有下载的数据 <code>DownloadService.sendRemoveAllDownloads</code>。</p><h3 id="5、启动和停止下载"><a href="#5、启动和停止下载" class="headerlink" title="5、启动和停止下载"></a>5、启动和停止下载</h3><p>只有满足四个条件时才会下载：</p><ul><li>下载没有停止原因（见下文）。</li><li>下载不会暂停。</li><li>满足下载进度的要求。要求可以指定对允许的网络类型的约束，以及设备是空闲还是连接到充电器。</li><li>不超过最大并行下载数。</li></ul><p>所有这些条件都可以通过发送命令来控制 <code>DownloadService</code>。</p><h4 id="1-、设置和清除下载停止原因"><a href="#1-、设置和清除下载停止原因" class="headerlink" title="(1)、设置和清除下载停止原因"></a>(1)、设置和清除下载停止原因</h4><p>可以设置停止一个或所有下载的原因：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">Set</span> the <span class="keyword">stop</span> reason <span class="keyword">for</span> a single download.</span><br><span class="line">DownloadService.sendSetStopReason(</span><br><span class="line">    <span class="keyword">context</span>,</span><br><span class="line">    MyDownloadService.class,</span><br><span class="line">    contentId,</span><br><span class="line">    stopReason,</span><br><span class="line">    <span class="comment">/* foreground= */</span> <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">// Clear the <span class="keyword">stop</span> reason <span class="keyword">for</span> a single download.</span><br><span class="line">DownloadService.sendSetStopReason(</span><br><span class="line">    <span class="keyword">context</span>,</span><br><span class="line">    MyDownloadService.class,</span><br><span class="line">    contentId,</span><br><span class="line">    Download.STOP_REASON_NONE,</span><br><span class="line">    <span class="comment">/* foreground= */</span> <span class="literal">false</span>);</span><br></pre></td></tr></tbody></table></figure><p><code>stopReason</code>可以是任何非零值（<code>Download.STOP_REASON_NONE = 0</code>是一个特殊值，意味着下载没有停止）。有多种停止下载原因的应用可以使用不同的值来跟踪每次下载停止的原因。设置和清除所有下载的停止原因与设置和清除单个下载的停止原因的方式相同，但<code>contentId</code>应设置为<code>null</code>。</p><p>当下载具有非零停止原因时，它将处于该 <code>Download.STATE_STOPPED</code>状态。</p><h4 id="2-、暂停和恢复所有下载"><a href="#2-、暂停和恢复所有下载" class="headerlink" title="(2)、暂停和恢复所有下载"></a>(2)、暂停和恢复所有下载</h4><p>所有下载都可以暂停并恢复如下：</p><figure class="highlight d"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pause all downloads.</span></span><br><span class="line">DownloadService.sendPauseDownloads(</span><br><span class="line">    context,</span><br><span class="line">    MyDownloadService.<span class="keyword">class</span>,</span><br><span class="line">    <span class="comment">/* foreground= */</span> <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Resume all downloads.</span></span><br><span class="line">DownloadService.sendResumeDownloads(</span><br><span class="line">    context,</span><br><span class="line">    MyDownloadService.<span class="keyword">class</span>,</span><br><span class="line">    <span class="comment">/* foreground= */</span> <span class="literal">false</span>);</span><br></pre></td></tr></tbody></table></figure><p>下载暂停时，它将处于该<code>Download.STATE_QUEUED</code>状态。</p><h4 id="3-、设置下载要求的进度"><a href="#3-、设置下载要求的进度" class="headerlink" title="(3)、设置下载要求的进度"></a>(3)、设置下载要求的进度</h4><p><code>Requirements</code>可用于指定下载继续进行必须满足的约束。可以通过<code>DownloadManager.setRequirements()</code>在创建时调用来设置要求 <code>DownloadManager</code>，如上例所示。它们也可以通过向以下命令发送命令来动态更改<code>DownloadService</code>：</p><figure class="highlight d"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set the download requirements.</span></span><br><span class="line">DownloadService.sendSetRequirements(</span><br><span class="line">    context,</span><br><span class="line">    MyDownloadService.<span class="keyword">class</span>,</span><br><span class="line">    requirements,</span><br><span class="line">    <span class="comment">/* foreground= */</span> <span class="literal">false</span>);</span><br></pre></td></tr></tbody></table></figure><p>如果由于未满足要求而无法继续下载，则它将处于该<code>Download.STATE_QUEUED</code>状态。您可以使用查询不满足的要求<code>DownloadManager.getNotMetRequirements()</code>。</p><h4 id="4-、设置最大并行下载数"><a href="#4-、设置最大并行下载数" class="headerlink" title="(4)、设置最大并行下载数"></a>(4)、设置最大并行下载数</h4><p>可以通过调用设置最大并行下载数 <code>DownloadManager.setMaxParallelDownloads()</code>。这通常在创建时完成<code>DownloadManager</code>，如上例所示。</p><p>如果由于最大并行下载数量已在进行而无法继续下载，则它将处于该<code>Download.STATE_QUEUED</code>状态。</p><h3 id="6、查询下载"><a href="#6、查询下载" class="headerlink" title="6、查询下载"></a>6、查询下载</h3><p><code>DownloadManager</code>的<code>DownloadIndex</code>可以查询所有下载，包括那些已完成或失败的状态。可以通过调用<code>DownloadManager.getDownloadIndex()</code>来获得该<code>DownloadIndex</code> 。然后可以通过调用<code>DownloadIndex.getDownloads()</code>获得迭代所有下载的游标 。或者，可以通过调用<code>DownloadIndex.getDownload()</code>查询单个下载的状态。</p><p><code>DownloadManager</code>还提供<code>DownloadManager.getCurrentDownloads()</code>，仅返回当前状态（即未完成或失败）的下载。此方法对于更新显示当前下载的进度和状态的通知和其他UI组件非常有用。</p><h3 id="7、听取下载"><a href="#7、听取下载" class="headerlink" title="7、听取下载"></a>7、听取下载</h3><p>您可以添加一个侦听器，<code>DownloadManager</code>以便在当前下载更改状态时收到通知：</p><figure class="highlight haxe"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">downloadManager.addListener(</span><br><span class="line">    <span class="keyword">new</span> <span class="type">DownloadManager</span>.Listener() {</span><br><span class="line">      <span class="comment">// Override methods of interest here.</span></span><br><span class="line">    });</span><br></pre></td></tr></tbody></table></figure><p>请参阅<code>DownloadManagerListener</code>演示应用程序<code>[DownloadTracker](https://github.com/google/ExoPlayer/tree/release-v2/demos/main/src/main/java/com/google/android/exoplayer2/demo/DownloadTracker.java)</code>类中的具体示例。</p><blockquote><p>下载进度更新不会触发调用<code>DownloadManager.Listener</code>。要更新显示下载进度的UI组件，您应该定期查询<code>DownloadManager</code>所需的更新速率。<code>DownloadService</code> 包含此示例，定期更新服务前台通知。</p></blockquote><h3 id="8、播放下载的内容"><a href="#8、播放下载的内容" class="headerlink" title="8、播放下载的内容"></a>8、播放下载的内容</h3><p>播放下载的内容类似于播放在线内容，除了从下载<code>Cache</code>而不是通过网络读取数据。</p><blockquote><p>请勿直接从下载目录中尝试读取文件，这一点很重要。而是使用如下所述的ExoPlayer库类。</p></blockquote><p>要播放下载的内容，请使用用于下载<code>CacheDataSourceFactory</code>的相同<code>Cache</code>实例创建一个。使用此工厂类，构建一个<code>MediaSource</code>播放。您应该使用原始内容<code>contentUri</code>（即下载的内容）构建<code>MediaSource</code>，而不是指向下载目录或其中任何文件的<code>URI</code>。</p><figure class="highlight subunit"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CacheDataSourceFactory dataSourceFactory = new CacheDataSourceFactory(</span><br><span class="line">    downloadCache, upstreamDataSourceFactory);</span><br><span class="line"><span class="keyword">Progress</span>iveMediaSource mediaSource = new ProgressiveMediaSource</span><br><span class="line">    .Factory(dataSourceFactory)</span><br><span class="line">    .createMediaSource(contentUri);</span><br><span class="line">player.prepare(mediaSource);</span><br></pre></td></tr></tbody></table></figure><h3 id="9、下载和播放自适应流"><a href="#9、下载和播放自适应流" class="headerlink" title="9、下载和播放自适应流"></a>9、下载和播放自适应流</h3><p>自适应流（例如<code>DASH</code>，<code>SmoothStreaming</code>和<code>HLS</code>）通常包含多个媒体轨道。通常有多个轨道包含不同质量的相同内容（例如<code>SD</code>，<code>HD</code>和<code>4K</code>视频轨道）。可能还存在包含不同内容的相同类型的多个轨道（例如，不同语言的多个音轨）。</p><p>对于流式播放，可以使用轨道选择器来选择播放哪个轨道。类似地，对于下载，<code>DownloadHelper</code>可以使用来选择下载哪个轨道。<code>DownloadHelper</code>的典型用法如下：</p><ul><li>使用其中一种<code>DownloadHelper.forXXX</code>方法构建一个<code>DownloadHelper</code>。</li><li>使用<code>prepare(DownloadHelper.Callback)</code>并准备帮助程序并等待回调。</li></ul><figure class="highlight autohotkey"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DownloadHelper downloadHelper =</span><br><span class="line">    DownloadHelper.forDash(</span><br><span class="line"><span class="built_in">        contentUri,</span></span><br><span class="line"><span class="built_in">        dataSourceFactory,</span></span><br><span class="line">        <span class="keyword">new</span> DefaultRenderersFactory(context))<span class="comment">;</span></span><br><span class="line">downloadHelper.prepare(myCallback)<span class="comment">;</span></span><br></pre></td></tr></tbody></table></figure><ul><li>可以选择使用检查默认选定的曲目 <code>getMappedTrackInfo</code> 和 <code>getTrackSelections</code> ，使用<code>clearTrackSelections</code>，<code>replaceTrackSelections</code>和<code>addTrackSelection</code>进行调整。</li><li>通过调用<code>getDownloadRequest</code>为所选曲目创建一个<code>DownloadRequest</code>。如上所述，请求可以传递给<code>DownloadService</code>添加下载。</li><li>使用<code>release()</code>释放<code>helper</code>。</li></ul><p>您可以通过调用<code>DownloadHelper.createMediaSource</code>以下内容创建<code>MediaSource</code>播放 ：</p><figure class="highlight ebnf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">MediaSource mediaSource</span> =</span><br><span class="line">    DownloadHelper.createMediaSource(downloadRequest, dataSourceFactory);</span><br></pre></td></tr></tbody></table></figure><p>创建<code>MediaSource</code>的人知道已下载了哪些曲目，因此只会在播放期间尝试使用这些曲目。请参阅 <a href="https://github.com/google/ExoPlayer/tree/release-v2/demos/main/src/main/java/com/google/android/exoplayer2/demo/PlayerActivity.java" target="_blank" rel="noopener">PlayerActivity</a> 演示应用程序中的具体示例。</p><hr><hr><hr><blockquote><p>转载此文请标明出处：<a href="https://blog.csdn.net/MRYZJ/article/details/98657228" target="_blank" rel="noopener">https://blog.csdn.net/MRYZJ/article/details/98657228</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
          <category> ExoPlayer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> ExoPlayer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模仿微信右上角弹出的菜单</title>
      <link href="/undefined/84ab7afd.html"/>
      <url>/undefined/84ab7afd.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近在看《Android精彩编程200例》这本书，但是书中很多例子都存在一些问题，因此我在这里就对书中的实例进行修改。希望能对一些和我一样的初学者有所帮助。</p></blockquote><p>首先来看一下效果图：<br>​​<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://img-blog.csdnimg.cn/20190809095910149.gif" alt="在这里插入图片描述"><br>废话不多说直接贴码分析。打开AS新建一个项目命名为 WeiMenu 。</p><p>这里我采用自己定义的标题栏，与书中使用一张图来代替标题栏不一样，我这样对屏幕的兼容和适配更加合理。新建一个 layout 文件命名为 title.xml 文件。</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"horizontal"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:padding</span>=<span class="string">"15dp"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:background</span>=<span class="string">"#000"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/title_name"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"40dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"@string/text_title"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">"center_horizontal"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">"#FFFFFF"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">"25sp"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"40dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">"center_horizontal"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/btn_menu"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"40dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"40dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignParentRight</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">"center_horizontal"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:focusable</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"@drawable/btn_add"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>接着在 MainActivity 这个类中输入以下代码，我采用自己定义的标题栏，因此在这里我隐藏系统的标题栏。</p><figure class="highlight scala"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mryzj.weimenu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.<span class="type">Bundle</span>;</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.<span class="type">ActionBar</span>;</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.<span class="type">AppCompatActivity</span>;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) {</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(<span class="type">R</span>.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//隐藏系统自带的标题栏</span></span><br><span class="line">        <span class="type">ActionBar</span> actionBar = getSupportActionBar();</span><br><span class="line">        <span class="keyword">if</span> (actionBar != <span class="literal">null</span>){</span><br><span class="line">            actionBar.hide();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>紧接着定义右上角菜单的有哪些选项内容，新建一个 layout 布局命名为 menu.xml 文件。</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:gravity</span>=<span class="string">"right"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--菜单发起群聊按钮--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginRight</span>=<span class="string">"10dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"#333333"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawableLeft</span>=<span class="string">"@drawable/icon_group"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawablePadding</span>=<span class="string">"10dip"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:paddingLeft</span>=<span class="string">"20dip"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:paddingRight</span>=<span class="string">"58dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"@string/text_group"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">"#FFFFFF"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">"18sp"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--菜单添加好友按钮--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginRight</span>=<span class="string">"10dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"#333333"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawableLeft</span>=<span class="string">"@drawable/icon_add"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawablePadding</span>=<span class="string">"10dip"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:paddingLeft</span>=<span class="string">"20dip"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:paddingRight</span>=<span class="string">"58dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"@string/text_add"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">"#FFFFFF"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">"18sp"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--菜单扫一扫按钮--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginRight</span>=<span class="string">"10dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"#333333"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawableLeft</span>=<span class="string">"@drawable/icon_scan"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawablePadding</span>=<span class="string">"10dip"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:paddingLeft</span>=<span class="string">"20dip"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:paddingRight</span>=<span class="string">"76dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"@string/text_sweep"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">"#FFFFFF"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">"18sp"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--菜单收付款按钮--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginRight</span>=<span class="string">"10dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"#333333"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawableLeft</span>=<span class="string">"@drawable/icon_card"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawablePadding</span>=<span class="string">"10dip"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:paddingLeft</span>=<span class="string">"20dip"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:paddingRight</span>=<span class="string">"76dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"@string/text_collect"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">"#FFFFFF"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">"18sp"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--菜单帮助与反馈按钮--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginRight</span>=<span class="string">"10dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"#333333"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawableLeft</span>=<span class="string">"@drawable/icon_help"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:drawablePadding</span>=<span class="string">"10dip"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:paddingLeft</span>=<span class="string">"20dip"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:paddingRight</span>=<span class="string">"40dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"@string/text_help"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textColor</span>=<span class="string">"#FFFFFF"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">"18sp"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>新建一个Java类来实现自定义的标题栏功能，命名为 TitleLayout.java 文件。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mryzj.weimenu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.ActionBar;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.util.AttributeSet;</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater;</span><br><span class="line"><span class="keyword">import</span> android.view.MotionEvent;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.LinearLayout;</span><br><span class="line"><span class="keyword">import</span> android.widget.PopupWindow;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TitleLayout</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Button menuBtn;</span><br><span class="line">    PopupWindow popupWindow;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TitleLayout</span><span class="params">(Context context)</span></span>{</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TitleLayout</span><span class="params">(<span class="keyword">final</span> Context context, AttributeSet attributeSet)</span></span>{</span><br><span class="line">        <span class="keyword">super</span>(context, attributeSet);</span><br><span class="line"></span><br><span class="line">        LayoutInflater.from(context).inflate(R.layout.title, <span class="keyword">this</span>);</span><br><span class="line">        menuBtn = findViewById(R.id.btn_menu);</span><br><span class="line"></span><br><span class="line">        menuBtn.setOnClickListener(<span class="keyword">new</span> View.OnClickListener(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span></span>{</span><br><span class="line">                <span class="comment">// 获取自定义的菜单布局文件</span></span><br><span class="line">                View popupWindow_view = LayoutInflater.from(context).inflate(R.layout.menu, <span class="keyword">null</span>,<span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">// 创建PopupWindow实例,设置菜单宽度和高度为包裹其自身内容</span></span><br><span class="line">                popupWindow = <span class="keyword">new</span> PopupWindow(popupWindow_view, ActionBar.LayoutParams.WRAP_CONTENT,</span><br><span class="line">                        ActionBar.LayoutParams.WRAP_CONTENT, <span class="keyword">true</span>);</span><br><span class="line">                <span class="comment">//设置菜单显示在按钮的下面</span></span><br><span class="line">                popupWindow.showAsDropDown(findViewById(R.id.btn_menu),<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">                <span class="comment">// 点击其他地方消失</span></span><br><span class="line">                popupWindow_view.setOnTouchListener(<span class="keyword">new</span> View.OnTouchListener() {</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>{</span><br><span class="line">                        <span class="comment">//如果菜单存在并且为显示状态，就关闭菜单并初始化菜单</span></span><br><span class="line">                        <span class="keyword">if</span> (popupWindow != <span class="keyword">null</span> &amp;&amp; popupWindow.isShowing()) {</span><br><span class="line">                            popupWindow.dismiss();</span><br><span class="line">                            popupWindow = <span class="keyword">null</span>;</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    }</span><br><span class="line">                });</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后一步，在 activity_main.xml 布局中引入定义好的标题栏。</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/activity_main"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">"com.mryzj.weimenu.MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.mryzj.weimenu.TitleLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">com.mryzj.weimenu.TitleLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>如有错误，欢迎指出！</p><p>这里是上述实例的源码，喜欢的朋友给颗星，谢谢：<a href="https://github.com/MrYZJ/wechat_title_menu" target="_blank" rel="noopener">https://github.com/MrYZJ/wechat_title_menu</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 菜单 </tag>
            
            <tag> 微信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转】博客开源</title>
      <link href="/undefined/e3e08109.html"/>
      <url>/undefined/e3e08109.html</url>
      
        <content type="html"><![CDATA[<h1 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h1><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://raw.githubusercontent.com/shw2018/cdn/master/blog_files/img/Blog-Open-Source/blog-demo1.gif" alt="演示Demo"></p><h1 id="简短介绍"><a href="#简短介绍" class="headerlink" title="简短介绍"></a>简短介绍</h1><p>倒腾了一两周总算把个人博客网站完善了，目前这个版本使用应该是够了，当然还有一些优化项和功能增加后续在慢慢更新，为了回馈开源，今天准备把我自己修改完善的<code>blog</code>网站源代码开源。这不是生成后的网页文件，是您可以直接使用的源码，您只需要把博客相关信息换成您自己的就可以部署了，对于新手或者不懂编程的小伙伴来说，简直是福音，极大简化了您构建博客的工作量和复杂度，每个人都可以下载并修改成自己喜欢样式！如果你有修改想法，欢迎PR！最后，我们还是给这个开源小项目取个名字吧，就叫<a href="https://github.com/shw2018/hexo-blog-fly.git" target="_blank" rel="noopener">hexo-blog-fly</a>吧，怎么样？&lt;&lt;&lt;&lt;&lt;<a href="https://github.com/shw2018/hexo-blog-fly" target="_blank" rel="noopener">源代码下载</a>&gt;&gt;&gt;&gt;&gt;</p><p>本博客基于<code>Hexo</code>框架搭建，用到<a href="https://github.com/shw2018/hexo-theme-matery" target="_blank" rel="noopener">hexo-theme-matery</a>主题, 并在此基础之上做了很多修改，修复了一些bug，增加了一些新的特性和功能，博客地址：<a href="https://shw2018.github.io/" target="_blank" rel="noopener">https://shw2018.github.io</a>，博客演示：<a href="https://sunhwee.com" target="_blank" rel="noopener">sunhwee.com</a>。</p><hr><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p><strong>原主题特性</strong>:</p><ul><li><p>简单漂亮，文章内容美观易读</p></li><li><p><a href="https://material.io/" target="_blank" rel="noopener">Material Design</a> 设计</p></li><li><p>响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现</p></li><li><p>首页轮播文章及每天动态切换 <code>Banner</code> 图片</p></li><li><p>瀑布流式的博客文章列表（文章无特色图片时会有 <code>24</code> 张漂亮的图片代替）</p></li><li><p>时间轴式的归档页</p></li><li><p><strong>词云</strong>的标签页和<strong>雷达图</strong>的分类页</p></li><li><p>丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等）</p></li><li><p>可自定义的数据的友情链接页面</p></li><li><p>支持文章置顶和文章打赏</p></li><li><p>支持 <code>MathJax</code></p></li><li><p><code>TOC</code> 目录</p></li><li><p>可设置复制文章内容时追加版权信息</p></li><li><p>可设置阅读文章时做密码验证</p></li><li><p><a href="https://gitalk.github.io/" target="_blank" rel="noopener">Gitalk</a>、<a href="https://imsun.github.io/gitment/" target="_blank" rel="noopener">Gitment</a>、<a href="https://valine.js.org/" target="_blank" rel="noopener">Valine</a> 和 <a href="https://disqus.com/" target="_blank" rel="noopener">Disqus</a> 评论模块（推荐使用 <code>Gitalk</code>）</p></li><li><p>集成了<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子统计</a>、谷歌分析（<code>Google Analytics</code>）和文章字数统计等功能</p></li><li><p>支持在首页的音乐播放和视频播放功能</p><p><strong>增加的工作或特性(未打钩的是已做但还没更新到源码的)</strong>:</p></li><li><p>修改了原主题的一些很多<code>bug</code>   2019.08.05</p></li><li><p>加入图片懒加载功能，在根目录配置文件开启和关闭    2019.08.09</p></li><li><p>增加<code>留言板</code>功能          2019.08.05</p></li><li><p>在关于板块,加入<code>简历</code>功能页   2019.08.05</p></li><li><p>增加视听[视觉听觉影音]板块       2019.08.10</p></li><li><p>支持<code>emoji</code>表情，用<code>markdown emoji</code>语法书写直接生成对应的能<strong>跳跃</strong>的表情。  2019.08.10</p></li><li><p>增加网站运行时间显示  2019.08.10</p></li><li><p>增加<code>动漫模型</code>     2019.08.10</p></li><li><p>整体替换Banner图片和文章特色图片   2019.08.10</p></li><li><p>增加分类<code>相册</code>功能         2019.08.29</p></li><li><p>去掉标签页,将其合并至<code>分类</code>页中                2019.09.01</p></li><li><p>修改了一些控件的参数   2019.09.01</p></li><li><p>修改部分样式,比如: 文章卡片,固定高度,使其不至于因为文章摘要的长短不同导致卡片大小不一使页面布局很不美观,类似的还有友链卡片,优化了页面内容布局,视觉更整齐美观          2019.09.01</p></li><li><p>解决首页文章列表卡片上方 <code>border-radius</code>圆角失效的bug  2019.09.01</p></li><li><p>添加页面樱花飘落动效            2019.09.09</p></li><li><p>添加鼠标点击烟花爆炸动效   2019.09.09</p></li><li><p>加入天气接口控件   2019.09.09</p></li><li><p>加入鼠标点击文字特效   2019.09.10</p></li><li><p>添加页面雪花飘落动效            2019.09.10</p></li><li><p>添加在线聊天插件            2019.09.12</p></li><li><p>持续更新…</p></li></ul><hr><p><strong>简单使用方法：</strong></p><ol><li><code>star</code> 本项目</li><li>安装<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a>, 安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">nodeJS</a></li><li>你可以直接<code>fork</code>一份源码到你的仓库，<code>clone</code>到本地</li><li>在本地博客仓库运行<code>npm i</code>命令安装依赖包</li><li>修改配置信息，改成自己的信息</li><li>运行命令<code>hexo  clean</code>（清除生成文件），<code>hexo g</code>（生成网页）， <code>hexo  s</code>（本地预览），<code>hexo d</code>（部署）</li></ol><blockquote><p><strong>更多详情教程，强烈推荐看我写的：<a href="https://sunhwee.com/posts/6e8839eb.html" target="_blank" rel="noopener">Hexo+Github博客搭建完全教程</a></strong></p></blockquote><blockquote><p><strong>最后，如果项目和教程对你有所帮助或者你看见了还算比较喜欢，欢迎给我<code>star</code>，谢谢您！</strong></p></blockquote><p><strong>持续更新中…，如果遇到问题欢迎联系我，在文章最后评论区【留言和讨论】，当然，欢迎点击文章最后的打赏按键，请博主一杯冰阔乐，笑～</strong></p><table>  <tbody><tr>    <td><img width="100" src="https://mryzj.github.io/medias/reward/alipay.bmp"></td>    <td><img width="100" src="https://mryzj.github.io/medias/reward/wechat.bmp"></td>    <td><img width="100" src="https://mryzj.github.io/medias/reward/zan.png"></td>     </tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 软件安装与配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Github </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
